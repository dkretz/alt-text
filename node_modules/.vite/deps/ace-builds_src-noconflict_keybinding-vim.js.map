{
  "version": 3,
  "sources": ["../../ace-builds/src-noconflict/keybinding-vim.js"],
  "sourcesContent": ["ace.define(\"ace/ext/hardwrap\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/editor\",\"ace/config\"], function(require, exports, module){\"use strict\";\nvar Range = require(\"../range\").Range;\nfunction hardWrap(editor, options) {\n    var max = options.column || editor.getOption(\"printMarginColumn\");\n    var allowMerge = options.allowMerge != false;\n    var row = Math.min(options.startRow, options.endRow);\n    var endRow = Math.max(options.startRow, options.endRow);\n    var session = editor.session;\n    while (row <= endRow) {\n        var line = session.getLine(row);\n        if (line.length > max) {\n            var space = findSpace(line, max, 5);\n            if (space) {\n                var indentation = /^\\s*/.exec(line)[0];\n                session.replace(new Range(row, space.start, row, space.end), \"\\n\" + indentation);\n            }\n            endRow++;\n        }\n        else if (allowMerge && /\\S/.test(line) && row != endRow) {\n            var nextLine = session.getLine(row + 1);\n            if (nextLine && /\\S/.test(nextLine)) {\n                var trimmedLine = line.replace(/\\s+$/, \"\");\n                var trimmedNextLine = nextLine.replace(/^\\s+/, \"\");\n                var mergedLine = trimmedLine + \" \" + trimmedNextLine;\n                var space = findSpace(mergedLine, max, 5);\n                if (space && space.start > trimmedLine.length || mergedLine.length < max) {\n                    var replaceRange = new Range(row, trimmedLine.length, row + 1, nextLine.length - trimmedNextLine.length);\n                    session.replace(replaceRange, \" \");\n                    row--;\n                    endRow--;\n                }\n                else if (trimmedLine.length < line.length) {\n                    session.remove(new Range(row, trimmedLine.length, row, line.length));\n                }\n            }\n        }\n        row++;\n    }\n    function findSpace(line, max, min) {\n        if (line.length < max)\n            return;\n        var before = line.slice(0, max);\n        var after = line.slice(max);\n        var spaceAfter = /^(?:(\\s+)|(\\S+)(\\s+))/.exec(after);\n        var spaceBefore = /(?:(\\s+)|(\\s+)(\\S+))$/.exec(before);\n        var start = 0;\n        var end = 0;\n        if (spaceBefore && !spaceBefore[2]) {\n            start = max - spaceBefore[1].length;\n            end = max;\n        }\n        if (spaceAfter && !spaceAfter[2]) {\n            if (!start)\n                start = max;\n            end = max + spaceAfter[1].length;\n        }\n        if (start) {\n            return {\n                start: start,\n                end: end\n            };\n        }\n        if (spaceBefore && spaceBefore[2] && spaceBefore.index > min) {\n            return {\n                start: spaceBefore.index,\n                end: spaceBefore.index + spaceBefore[2].length\n            };\n        }\n        if (spaceAfter && spaceAfter[2]) {\n            start = max + spaceAfter[2].length;\n            return {\n                start: start,\n                end: start + spaceAfter[3].length\n            };\n        }\n    }\n}\nfunction wrapAfterInput(e) {\n    if (e.command.name == \"insertstring\" && /\\S/.test(e.args)) {\n        var editor = e.editor;\n        var cursor = editor.selection.cursor;\n        if (cursor.column <= editor.renderer.$printMarginColumn)\n            return;\n        var lastDelta = editor.session.$undoManager.$lastDelta;\n        hardWrap(editor, {\n            startRow: cursor.row, endRow: cursor.row,\n            allowMerge: false\n        });\n        if (lastDelta != editor.session.$undoManager.$lastDelta)\n            editor.session.markUndoGroup();\n    }\n}\nvar Editor = require(\"../editor\").Editor;\nrequire(\"../config\").defineOptions(Editor.prototype, \"editor\", {\n    hardWrap: {\n        set: function (val) {\n            if (val) {\n                this.commands.on(\"afterExec\", wrapAfterInput);\n            }\n            else {\n                this.commands.off(\"afterExec\", wrapAfterInput);\n            }\n        },\n        value: false\n    }\n});\nexports.hardWrap = hardWrap;\n\n});\n\nace.define(\"ace/keyboard/vim\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/lib/event_emitter\",\"ace/lib/dom\",\"ace/lib/oop\",\"ace/lib/keys\",\"ace/lib/event\",\"ace/search\",\"ace/lib/useragent\",\"ace/search_highlight\",\"ace/commands/multi_select_commands\",\"ace/mode/text\",\"ace/ext/hardwrap\",\"ace/multi_select\"], function(require, exports, module){// CodeMirror, copyright (c) by Marijn Haverbeke and others\n'use strict';\nfunction log() {\n    var d = \"\";\n    function format(p) {\n        if (typeof p != \"object\")\n            return p + \"\";\n        if (\"line\" in p) {\n            return p.line + \":\" + p.ch;\n        }\n        if (\"anchor\" in p) {\n            return format(p.anchor) + \"->\" + format(p.head);\n        }\n        if (Array.isArray(p))\n            return \"[\" + p.map(function (x) {\n                return format(x);\n            }) + \"]\";\n        return JSON.stringify(p);\n    }\n    for (var i = 0; i < arguments.length; i++) {\n        var p = arguments[i];\n        var f = format(p);\n        d += f + \"  \";\n    }\n    console.log(d);\n}\nvar Range = require(\"../range\").Range;\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\nvar domLib = require(\"../lib/dom\");\nvar oop = require(\"../lib/oop\");\nvar KEYS = require(\"../lib/keys\");\nvar event = require(\"../lib/event\");\nvar Search = require(\"../search\").Search;\nvar useragent = require(\"../lib/useragent\");\nvar SearchHighlight = require(\"../search_highlight\").SearchHighlight;\nvar multiSelectCommands = require(\"../commands/multi_select_commands\");\nvar TextModeTokenRe = require(\"../mode/text\").Mode.prototype.tokenRe;\nvar hardWrap = require(\"../ext/hardwrap\").hardWrap;\nrequire(\"../multi_select\");\nvar CodeMirror = function (ace) {\n    this.ace = ace;\n    this.state = {};\n    this.marks = {};\n    this.options = {};\n    this.$uid = 0;\n    this.onChange = this.onChange.bind(this);\n    this.onSelectionChange = this.onSelectionChange.bind(this);\n    this.onBeforeEndOperation = this.onBeforeEndOperation.bind(this);\n    this.ace.on('change', this.onChange);\n    this.ace.on('changeSelection', this.onSelectionChange);\n    this.ace.on('beforeEndOperation', this.onBeforeEndOperation);\n};\nCodeMirror.Pos = function (line, ch) {\n    if (!(this instanceof Pos))\n        return new Pos(line, ch);\n    this.line = line;\n    this.ch = ch;\n};\nCodeMirror.defineOption = function (name, val, setter) { };\nCodeMirror.commands = {\n    redo: function (cm) { cm.ace.redo(); },\n    undo: function (cm) { cm.ace.undo(); },\n    newlineAndIndent: function (cm) { cm.ace.insert(\"\\n\"); },\n    goLineLeft: function (cm) { cm.ace.selection.moveCursorLineStart(); },\n    goLineRight: function (cm) { cm.ace.selection.moveCursorLineEnd(); }\n};\nCodeMirror.keyMap = {};\nCodeMirror.addClass = CodeMirror.rmClass = function () { };\nCodeMirror.e_stop = CodeMirror.e_preventDefault = event.stopEvent;\nCodeMirror.keyName = function (e) {\n    var key = (KEYS[e.keyCode] || e.key || \"\");\n    if (key.length == 1)\n        key = key.toUpperCase();\n    key = event.getModifierString(e).replace(/(^|-)\\w/g, function (m) {\n        return m.toUpperCase();\n    }) + key;\n    return key;\n};\nCodeMirror.keyMap['default'] = function (key) {\n    return function (cm) {\n        var cmd = cm.ace.commands.commandKeyBinding[key.toLowerCase()];\n        return cmd && cm.ace.execCommand(cmd) !== false;\n    };\n};\nCodeMirror.lookupKey = function lookupKey(key, map, handle) {\n    if (!map)\n        map = \"default\";\n    if (typeof map == \"string\")\n        map = CodeMirror.keyMap[map] || CodeMirror.keyMap['default'];\n    var found = typeof map == \"function\" ? map(key) : map[key];\n    if (found === false)\n        return \"nothing\";\n    if (found === \"...\")\n        return \"multi\";\n    if (found != null && handle(found))\n        return \"handled\";\n    if (map.fallthrough) {\n        if (!Array.isArray(map.fallthrough))\n            return lookupKey(key, map.fallthrough, handle);\n        for (var i = 0; i < map.fallthrough.length; i++) {\n            var result = lookupKey(key, map.fallthrough[i], handle);\n            if (result)\n                return result;\n        }\n    }\n};\nCodeMirror.findMatchingTag = function (cm, head) {\n    return cm.findMatchingTag(head);\n};\nCodeMirror.findEnclosingTag = function (cm, head) {\n};\nCodeMirror.signal = function (o, name, e) { return o._signal(name, e); };\nCodeMirror.on = event.addListener;\nCodeMirror.off = event.removeListener;\nCodeMirror.isWordChar = function (ch) {\n    if (ch < \"\\x7f\")\n        return /^\\w$/.test(ch);\n    TextModeTokenRe.lastIndex = 0;\n    return TextModeTokenRe.test(ch);\n};\n(function () {\n    oop.implement(CodeMirror.prototype, EventEmitter);\n    this.destroy = function () {\n        this.ace.off('change', this.onChange);\n        this.ace.off('changeSelection', this.onSelectionChange);\n        this.ace.off('beforeEndOperation', this.onBeforeEndOperation);\n        this.removeOverlay();\n    };\n    this.virtualSelectionMode = function () {\n        return this.ace.inVirtualSelectionMode && this.ace.selection.index;\n    };\n    this.onChange = function (delta) {\n        if (this.$lineHandleChanges) {\n            this.$lineHandleChanges.push(delta);\n        }\n        var change = { text: delta.action[0] == 'i' ? delta.lines : [] };\n        var curOp = this.curOp = this.curOp || {};\n        if (!curOp.changeHandlers)\n            curOp.changeHandlers = this._eventRegistry[\"change\"] && this._eventRegistry[\"change\"].slice();\n        if (!curOp.lastChange) {\n            curOp.lastChange = curOp.change = change;\n        }\n        else {\n            curOp.lastChange.next = curOp.lastChange = change;\n        }\n        this.$updateMarkers(delta);\n    };\n    this.onSelectionChange = function () {\n        var curOp = this.curOp = this.curOp || {};\n        if (!curOp.cursorActivityHandlers)\n            curOp.cursorActivityHandlers = this._eventRegistry[\"cursorActivity\"] && this._eventRegistry[\"cursorActivity\"].slice();\n        this.curOp.cursorActivity = true;\n        if (this.ace.inMultiSelectMode) {\n            this.ace.keyBinding.removeKeyboardHandler(multiSelectCommands.keyboardHandler);\n        }\n    };\n    this.operation = function (fn, force) {\n        if (!force && this.curOp || force && this.curOp && this.curOp.force) {\n            return fn();\n        }\n        if (force || !this.ace.curOp) {\n            if (this.curOp)\n                this.onBeforeEndOperation();\n        }\n        if (!this.ace.curOp) {\n            var prevOp = this.ace.prevOp;\n            this.ace.startOperation({\n                command: { name: \"vim\", scrollIntoView: \"cursor\" }\n            });\n        }\n        var curOp = this.curOp = this.curOp || {};\n        this.curOp.force = force;\n        var result = fn();\n        if (this.ace.curOp && this.ace.curOp.command.name == \"vim\") {\n            if (this.state.dialog)\n                this.ace.curOp.command.scrollIntoView = this.ace.curOp.vimDialogScroll;\n            this.ace.endOperation();\n            if (!curOp.cursorActivity && !curOp.lastChange && prevOp)\n                this.ace.prevOp = prevOp;\n        }\n        if (force || !this.ace.curOp) {\n            if (this.curOp)\n                this.onBeforeEndOperation();\n        }\n        return result;\n    };\n    this.onBeforeEndOperation = function () {\n        var op = this.curOp;\n        if (op) {\n            if (op.change) {\n                this.signal(\"change\", op.change, op);\n            }\n            if (op && op.cursorActivity) {\n                this.signal(\"cursorActivity\", null, op);\n            }\n            this.curOp = null;\n        }\n    };\n    this.signal = function (eventName, e, handlers) {\n        var listeners = handlers ? handlers[eventName + \"Handlers\"]\n            : (this._eventRegistry || {})[eventName];\n        if (!listeners)\n            return;\n        listeners = listeners.slice();\n        for (var i = 0; i < listeners.length; i++)\n            listeners[i](this, e);\n    };\n    this.firstLine = function () { return 0; };\n    this.lastLine = function () { return this.ace.session.getLength() - 1; };\n    this.lineCount = function () { return this.ace.session.getLength(); };\n    this.setCursor = function (line, ch) {\n        if (typeof line === 'object') {\n            ch = line.ch;\n            line = line.line;\n        }\n        var shouldScroll = !this.curOp && !this.ace.inVirtualSelectionMode;\n        if (!this.ace.inVirtualSelectionMode)\n            this.ace.exitMultiSelectMode();\n        this.ace.session.unfold({ row: line, column: ch });\n        this.ace.selection.moveTo(line, ch);\n        if (shouldScroll) {\n            this.ace.renderer.scrollCursorIntoView();\n            this.ace.endOperation();\n        }\n    };\n    this.getCursor = function (p) {\n        var sel = this.ace.selection;\n        var pos = p == 'anchor' ? (sel.isEmpty() ? sel.lead : sel.anchor) :\n            p == 'head' || !p ? sel.lead : sel.getRange()[p];\n        return toCmPos(pos);\n    };\n    this.listSelections = function (p) {\n        var ranges = this.ace.multiSelect.rangeList.ranges;\n        if (!ranges.length || this.ace.inVirtualSelectionMode)\n            return [{ anchor: this.getCursor('anchor'), head: this.getCursor('head') }];\n        return ranges.map(function (r) {\n            return {\n                anchor: this.clipPos(toCmPos(r.cursor == r.end ? r.start : r.end)),\n                head: this.clipPos(toCmPos(r.cursor))\n            };\n        }, this);\n    };\n    this.setSelections = function (p, primIndex) {\n        var sel = this.ace.multiSelect;\n        var ranges = p.map(function (x) {\n            var anchor = toAcePos(x.anchor);\n            var head = toAcePos(x.head);\n            var r = Range.comparePoints(anchor, head) < 0\n                ? new Range.fromPoints(anchor, head)\n                : new Range.fromPoints(head, anchor);\n            r.cursor = Range.comparePoints(r.start, head) ? r.end : r.start;\n            return r;\n        });\n        if (this.ace.inVirtualSelectionMode) {\n            this.ace.selection.fromOrientedRange(ranges[0]);\n            return;\n        }\n        if (!primIndex) {\n            ranges = ranges.reverse();\n        }\n        else if (ranges[primIndex]) {\n            ranges.push(ranges.splice(primIndex, 1)[0]);\n        }\n        sel.toSingleRange(ranges[0].clone());\n        var session = this.ace.session;\n        for (var i = 0; i < ranges.length; i++) {\n            var range = session.$clipRangeToDocument(ranges[i]); // todo why ace doesn't do this?\n            sel.addRange(range);\n        }\n    };\n    this.setSelection = function (a, h, options) {\n        var sel = this.ace.selection;\n        sel.moveTo(a.line, a.ch);\n        sel.selectTo(h.line, h.ch);\n        if (options && options.origin == '*mouse') {\n            this.onBeforeEndOperation();\n        }\n    };\n    this.somethingSelected = function (p) {\n        return !this.ace.selection.isEmpty();\n    };\n    this.clipPos = function (p) {\n        var pos = this.ace.session.$clipPositionToDocument(p.line, p.ch);\n        return toCmPos(pos);\n    };\n    this.foldCode = function (pos) {\n        this.ace.session.$toggleFoldWidget(pos.line, {});\n    };\n    this.markText = function (cursor) {\n        return { clear: function () { }, find: function () { } };\n    };\n    this.$updateMarkers = function (delta) {\n        var isInsert = delta.action == \"insert\";\n        var start = delta.start;\n        var end = delta.end;\n        var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);\n        var colShift = (end.column - start.column) * (isInsert ? 1 : -1);\n        if (isInsert)\n            end = start;\n        for (var i in this.marks) {\n            var point = this.marks[i];\n            var cmp = Range.comparePoints(point, start);\n            if (cmp < 0) {\n                continue; // delta starts after the range\n            }\n            if (cmp === 0) {\n                if (isInsert) {\n                    if (!point.$insertRight) {\n                        cmp = 1;\n                    }\n                    else if (point.bias == 1) {\n                        cmp = 1;\n                    }\n                    else {\n                        point.bias = -1;\n                        continue;\n                    }\n                }\n            }\n            var cmp2 = isInsert ? cmp : Range.comparePoints(point, end);\n            if (cmp2 > 0) {\n                point.row += rowShift;\n                point.column += point.row == end.row ? colShift : 0;\n                continue;\n            }\n            if (!isInsert && cmp2 <= 0) {\n                point.row = start.row;\n                point.column = start.column;\n                if (cmp2 === 0)\n                    point.bias = 1;\n            }\n        }\n    };\n    var Marker = function (cm, id, row, column) {\n        this.cm = cm;\n        this.id = id;\n        this.row = row;\n        this.column = column;\n        cm.marks[this.id] = this;\n    };\n    Marker.prototype.clear = function () { delete this.cm.marks[this.id]; };\n    Marker.prototype.find = function () { return toCmPos(this); };\n    this.setBookmark = function (cursor, options) {\n        var bm = new Marker(this, this.$uid++, cursor.line, cursor.ch);\n        if (!options || !options.insertLeft)\n            bm.$insertRight = true;\n        this.marks[bm.id] = bm;\n        return bm;\n    };\n    this.moveH = function (increment, unit) {\n        if (unit == 'char') {\n            var sel = this.ace.selection;\n            sel.clearSelection();\n            sel.moveCursorBy(0, increment);\n        }\n    };\n    this.findPosV = function (start, amount, unit, goalColumn) {\n        if (unit == 'page') {\n            var renderer = this.ace.renderer;\n            var config = renderer.layerConfig;\n            amount = amount * Math.floor(config.height / config.lineHeight);\n            unit = 'line';\n        }\n        if (unit == 'line') {\n            var screenPos = this.ace.session.documentToScreenPosition(start.line, start.ch);\n            if (goalColumn != null)\n                screenPos.column = goalColumn;\n            screenPos.row += amount;\n            screenPos.row = Math.min(Math.max(0, screenPos.row), this.ace.session.getScreenLength() - 1);\n            var pos = this.ace.session.screenToDocumentPosition(screenPos.row, screenPos.column);\n            return toCmPos(pos);\n        }\n        else {\n            debugger;\n        }\n    };\n    this.charCoords = function (pos, mode) {\n        if (mode == 'div' || !mode) {\n            var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\n            return { left: sc.column, top: sc.row };\n        }\n        if (mode == 'local') {\n            var renderer = this.ace.renderer;\n            var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\n            var lh = renderer.layerConfig.lineHeight;\n            var cw = renderer.layerConfig.characterWidth;\n            var top = lh * sc.row;\n            return { left: sc.column * cw, top: top, bottom: top + lh };\n        }\n    };\n    this.coordsChar = function (pos, mode) {\n        var renderer = this.ace.renderer;\n        if (mode == 'local') {\n            var row = Math.max(0, Math.floor(pos.top / renderer.lineHeight));\n            var col = Math.max(0, Math.floor(pos.left / renderer.characterWidth));\n            var ch = renderer.session.screenToDocumentPosition(row, col);\n            return toCmPos(ch);\n        }\n        else if (mode == 'div') {\n            throw \"not implemented\";\n        }\n    };\n    this.getSearchCursor = function (query, pos, caseFold) {\n        var caseSensitive = false;\n        var isRegexp = false;\n        if (query instanceof RegExp && !query.global) {\n            caseSensitive = !query.ignoreCase;\n            query = query.source;\n            isRegexp = true;\n        }\n        if (query == \"\\\\n\") {\n            query = \"\\n\";\n            isRegexp = false;\n        }\n        var search = new Search();\n        if (pos.ch == undefined)\n            pos.ch = Number.MAX_VALUE;\n        var acePos = { row: pos.line, column: pos.ch };\n        var cm = this;\n        var last = null;\n        return {\n            findNext: function () { return this.find(false); },\n            findPrevious: function () { return this.find(true); },\n            find: function (back) {\n                search.setOptions({\n                    needle: query,\n                    caseSensitive: caseSensitive,\n                    wrap: false,\n                    backwards: back,\n                    regExp: isRegexp,\n                    start: last || acePos\n                });\n                var range = search.find(cm.ace.session);\n                last = range;\n                return last && [!last.isEmpty()];\n            },\n            from: function () { return last && toCmPos(last.start); },\n            to: function () { return last && toCmPos(last.end); },\n            replace: function (text) {\n                if (last) {\n                    last.end = cm.ace.session.doc.replace(last, text);\n                }\n            }\n        };\n    };\n    this.scrollTo = function (x, y) {\n        var renderer = this.ace.renderer;\n        var config = renderer.layerConfig;\n        var maxHeight = config.maxHeight;\n        maxHeight -= (renderer.$size.scrollerHeight - renderer.lineHeight) * renderer.$scrollPastEnd;\n        if (y != null)\n            this.ace.session.setScrollTop(Math.max(0, Math.min(y, maxHeight)));\n        if (x != null)\n            this.ace.session.setScrollLeft(Math.max(0, Math.min(x, config.width)));\n    };\n    this.scrollInfo = function () { return 0; };\n    this.scrollIntoView = function (pos, margin) {\n        if (pos) {\n            var renderer = this.ace.renderer;\n            var viewMargin = { \"top\": 0, \"bottom\": margin };\n            renderer.scrollCursorIntoView(toAcePos(pos), (renderer.lineHeight * 2) / renderer.$size.scrollerHeight, viewMargin);\n        }\n    };\n    this.getLine = function (row) { return this.ace.session.getLine(row); };\n    this.getRange = function (s, e) {\n        return this.ace.session.getTextRange(new Range(s.line, s.ch, e.line, e.ch));\n    };\n    this.replaceRange = function (text, s, e) {\n        if (!e)\n            e = s;\n        var range = new Range(s.line, s.ch, e.line, e.ch);\n        this.ace.session.$clipRangeToDocument(range);\n        return this.ace.session.replace(range, text);\n    };\n    this.replaceSelection =\n        this.replaceSelections = function (p) {\n            var strings = Array.isArray(p) && p;\n            var sel = this.ace.selection;\n            if (this.ace.inVirtualSelectionMode) {\n                this.ace.session.replace(sel.getRange(), strings ? p[0] || \"\" : p);\n                return;\n            }\n            sel.inVirtualSelectionMode = true;\n            var ranges = sel.rangeList.ranges;\n            if (!ranges.length)\n                ranges = [this.ace.multiSelect.getRange()];\n            for (var i = ranges.length; i--;)\n                this.ace.session.replace(ranges[i], strings ? p[i] || \"\" : p);\n            sel.inVirtualSelectionMode = false;\n        };\n    this.getSelection = function () {\n        return this.ace.getSelectedText();\n    };\n    this.getSelections = function () {\n        return this.listSelections().map(function (x) {\n            return this.getRange(x.anchor, x.head);\n        }, this);\n    };\n    this.getInputField = function () {\n        return this.ace.textInput.getElement();\n    };\n    this.getWrapperElement = function () {\n        return this.ace.container;\n    };\n    var optMap = {\n        indentWithTabs: \"useSoftTabs\",\n        indentUnit: \"tabSize\",\n        tabSize: \"tabSize\",\n        firstLineNumber: \"firstLineNumber\",\n        readOnly: \"readOnly\"\n    };\n    this.setOption = function (name, val) {\n        this.state[name] = val;\n        switch (name) {\n            case 'indentWithTabs':\n                name = optMap[name];\n                val = !val;\n                break;\n            case 'keyMap':\n                this.state.$keyMap = val;\n                return;\n                break;\n            default:\n                name = optMap[name];\n        }\n        if (name)\n            this.ace.setOption(name, val);\n    };\n    this.getOption = function (name) {\n        var val;\n        var aceOpt = optMap[name];\n        if (aceOpt)\n            val = this.ace.getOption(aceOpt);\n        switch (name) {\n            case 'indentWithTabs':\n                name = optMap[name];\n                return !val;\n            case 'keyMap':\n                return this.state.$keyMap || 'vim';\n        }\n        return aceOpt ? val : this.state[name];\n    };\n    this.toggleOverwrite = function (on) {\n        this.state.overwrite = on;\n        return this.ace.setOverwrite(on);\n    };\n    this.addOverlay = function (o) {\n        if (!this.$searchHighlight || !this.$searchHighlight.session) {\n            var highlight = new SearchHighlight(null, \"ace_highlight-marker\", \"text\");\n            var marker = this.ace.session.addDynamicMarker(highlight);\n            highlight.id = marker.id;\n            highlight.session = this.ace.session;\n            highlight.destroy = function (o) {\n                highlight.session.off(\"change\", highlight.updateOnChange);\n                highlight.session.off(\"changeEditor\", highlight.destroy);\n                highlight.session.removeMarker(highlight.id);\n                highlight.session = null;\n            };\n            highlight.updateOnChange = function (delta) {\n                var row = delta.start.row;\n                if (row == delta.end.row)\n                    highlight.cache[row] = undefined;\n                else\n                    highlight.cache.splice(row, highlight.cache.length);\n            };\n            highlight.session.on(\"changeEditor\", highlight.destroy);\n            highlight.session.on(\"change\", highlight.updateOnChange);\n        }\n        var re = new RegExp(o.query.source, \"gmi\");\n        this.$searchHighlight = o.highlight = highlight;\n        this.$searchHighlight.setRegexp(re);\n        this.ace.renderer.updateBackMarkers();\n    };\n    this.removeOverlay = function (o) {\n        if (this.$searchHighlight && this.$searchHighlight.session) {\n            this.$searchHighlight.destroy();\n        }\n    };\n    this.getScrollInfo = function () {\n        var renderer = this.ace.renderer;\n        var config = renderer.layerConfig;\n        return {\n            left: renderer.scrollLeft,\n            top: renderer.scrollTop,\n            height: config.maxHeight,\n            width: config.width,\n            clientHeight: config.height,\n            clientWidth: config.width\n        };\n    };\n    this.getValue = function () {\n        return this.ace.getValue();\n    };\n    this.setValue = function (v) {\n        return this.ace.setValue(v, -1);\n    };\n    this.getTokenTypeAt = function (pos) {\n        var token = this.ace.session.getTokenAt(pos.line, pos.ch);\n        return token && /comment|string/.test(token.type) ? \"string\" : \"\";\n    };\n    this.findMatchingBracket = function (pos) {\n        var m = this.ace.session.findMatchingBracket(toAcePos(pos));\n        return { to: m && toCmPos(m) };\n    };\n    this.findMatchingTag = function (pos) {\n        var m = this.ace.session.getMatchingTags(toAcePos(pos));\n        if (!m)\n            return;\n        return {\n            open: {\n                from: toCmPos(m.openTag.start),\n                to: toCmPos(m.openTag.end)\n            },\n            close: {\n                from: toCmPos(m.closeTag.start),\n                to: toCmPos(m.closeTag.end)\n            }\n        };\n    };\n    this.indentLine = function (line, method) {\n        if (method === true)\n            this.ace.session.indentRows(line, line, \"\\t\");\n        else if (method === false)\n            this.ace.session.outdentRows(new Range(line, 0, line, 0));\n    };\n    this.indexFromPos = function (pos) {\n        return this.ace.session.doc.positionToIndex(toAcePos(pos));\n    };\n    this.posFromIndex = function (index) {\n        return toCmPos(this.ace.session.doc.indexToPosition(index));\n    };\n    this.focus = function (index) {\n        return this.ace.textInput.focus();\n    };\n    this.blur = function (index) {\n        return this.ace.blur();\n    };\n    this.defaultTextHeight = function (index) {\n        return this.ace.renderer.layerConfig.lineHeight;\n    };\n    this.scanForBracket = function (pos, dir, _, options) {\n        var re = options.bracketRegex.source;\n        var tokenRe = /paren|text|operator|tag/;\n        if (dir == 1) {\n            var m = this.ace.session.$findClosingBracket(re.slice(1, 2), toAcePos(pos), tokenRe);\n        }\n        else {\n            var m = this.ace.session.$findOpeningBracket(re.slice(-2, -1), { row: pos.line, column: pos.ch + 1 }, tokenRe);\n            if (!m && options.bracketRegex && options.bracketRegex.test(this.getLine(pos.line)[pos.ch - 1])) {\n                m = { row: pos.line, column: pos.ch - 1 };\n            }\n        }\n        return m && { pos: toCmPos(m) };\n    };\n    this.refresh = function () {\n        return this.ace.resize(true);\n    };\n    this.getMode = function () {\n        return { name: this.getOption(\"mode\") };\n    };\n    this.execCommand = function (name) {\n        if (CodeMirror.commands.hasOwnProperty(name))\n            return CodeMirror.commands[name](this);\n        if (name == \"indentAuto\")\n            return this.ace.execCommand(\"autoindent\");\n        console.log(name + \" is not implemented\");\n    };\n    this.getLineNumber = function (handle) {\n        var deltas = this.$lineHandleChanges;\n        if (!deltas)\n            return null;\n        var row = handle.row;\n        for (var i = 0; i < deltas.length; i++) {\n            var delta = deltas[i];\n            if (delta.start.row != delta.end.row) {\n                if (delta.action[0] == \"i\") {\n                    if (delta.start.row < row)\n                        row += delta.end.row - delta.start.row;\n                }\n                else {\n                    if (delta.start.row < row) {\n                        if (row < delta.end.row || row == delta.end.row && delta.start.column > 0) {\n                            return null;\n                        }\n                        row -= delta.end.row - delta.start.row;\n                    }\n                }\n            }\n        }\n        return row;\n    };\n    this.getLineHandle = function (row) {\n        if (!this.$lineHandleChanges)\n            this.$lineHandleChanges = [];\n        return { text: this.ace.session.getLine(row), row: row };\n    };\n    this.releaseLineHandles = function () {\n        this.$lineHandleChanges = undefined;\n    };\n    this.getLastEditEnd = function () {\n        var undoManager = this.ace.session.$undoManager;\n        if (undoManager && undoManager.$lastDelta)\n            return toCmPos(undoManager.$lastDelta.end);\n    };\n}).call(CodeMirror.prototype);\nfunction toAcePos(cmPos) {\n    return { row: cmPos.line, column: cmPos.ch };\n}\nfunction toCmPos(acePos) {\n    return new Pos(acePos.row, acePos.column);\n}\nvar StringStream = CodeMirror.StringStream = function (string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n};\nStringStream.prototype = {\n    eol: function () { return this.pos >= this.string.length; },\n    sol: function () { return this.pos == this.lineStart; },\n    peek: function () { return this.string.charAt(this.pos) || undefined; },\n    next: function () {\n        if (this.pos < this.string.length)\n            return this.string.charAt(this.pos++);\n    },\n    eat: function (match) {\n        var ch = this.string.charAt(this.pos);\n        if (typeof match == \"string\")\n            var ok = ch == match;\n        else\n            var ok = ch && (match.test ? match.test(ch) : match(ch));\n        if (ok) {\n            ++this.pos;\n            return ch;\n        }\n    },\n    eatWhile: function (match) {\n        var start = this.pos;\n        while (this.eat(match)) { }\n        return this.pos > start;\n    },\n    eatSpace: function () {\n        var start = this.pos;\n        while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos)))\n            ++this.pos;\n        return this.pos > start;\n    },\n    skipToEnd: function () { this.pos = this.string.length; },\n    skipTo: function (ch) {\n        var found = this.string.indexOf(ch, this.pos);\n        if (found > -1) {\n            this.pos = found;\n            return true;\n        }\n    },\n    backUp: function (n) { this.pos -= n; },\n    column: function () {\n        throw \"not implemented\";\n    },\n    indentation: function () {\n        throw \"not implemented\";\n    },\n    match: function (pattern, consume, caseInsensitive) {\n        if (typeof pattern == \"string\") {\n            var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\n            var substr = this.string.substr(this.pos, pattern.length);\n            if (cased(substr) == cased(pattern)) {\n                if (consume !== false)\n                    this.pos += pattern.length;\n                return true;\n            }\n        }\n        else {\n            var match = this.string.slice(this.pos).match(pattern);\n            if (match && match.index > 0)\n                return null;\n            if (match && consume !== false)\n                this.pos += match[0].length;\n            return match;\n        }\n    },\n    current: function () { return this.string.slice(this.start, this.pos); },\n    hideFirstChars: function (n, inner) {\n        this.lineStart += n;\n        try {\n            return inner();\n        }\n        finally {\n            this.lineStart -= n;\n        }\n    }\n};\nCodeMirror.defineExtension = function (name, fn) {\n    CodeMirror.prototype[name] = fn;\n};\ndomLib.importCssString(\".normal-mode .ace_cursor{\\n    border: none;\\n    background-color: rgba(255,0,0,0.5);\\n}\\n.normal-mode .ace_hidden-cursors .ace_cursor{\\n  background-color: transparent;\\n  border: 1px solid red;\\n  opacity: 0.7\\n}\\n.ace_dialog {\\n  position: absolute;\\n  left: 0; right: 0;\\n  background: inherit;\\n  z-index: 15;\\n  padding: .1em .8em;\\n  overflow: hidden;\\n  color: inherit;\\n}\\n.ace_dialog-top {\\n  border-bottom: 1px solid #444;\\n  top: 0;\\n}\\n.ace_dialog-bottom {\\n  border-top: 1px solid #444;\\n  bottom: 0;\\n}\\n.ace_dialog input {\\n  border: none;\\n  outline: none;\\n  background: transparent;\\n  width: 20em;\\n  color: inherit;\\n  font-family: monospace;\\n}\", \"vimMode\", false);\n(function () {\n    function dialogDiv(cm, template, bottom) {\n        var wrap = cm.ace.container;\n        var dialog;\n        dialog = wrap.appendChild(document.createElement(\"div\"));\n        if (bottom)\n            dialog.className = \"ace_dialog ace_dialog-bottom\";\n        else\n            dialog.className = \"ace_dialog ace_dialog-top\";\n        if (typeof template == \"string\") {\n            dialog.innerHTML = template;\n        }\n        else { // Assuming it's a detached DOM element.\n            dialog.appendChild(template);\n        }\n        return dialog;\n    }\n    function closeNotification(cm, newVal) {\n        if (cm.state.currentNotificationClose)\n            cm.state.currentNotificationClose();\n        cm.state.currentNotificationClose = newVal;\n    }\n    CodeMirror.defineExtension(\"openDialog\", function (template, callback, options) {\n        if (this.virtualSelectionMode())\n            return;\n        if (!options)\n            options = {};\n        closeNotification(this, null);\n        var dialog = dialogDiv(this, template, options.bottom);\n        var closed = false, me = this;\n        this.state.dialog = dialog;\n        function close(newVal) {\n            if (typeof newVal == 'string') {\n                inp.value = newVal;\n            }\n            else {\n                if (closed)\n                    return;\n                if (newVal && newVal.type == \"blur\") {\n                    if (document.activeElement === inp)\n                        return;\n                }\n                if (me.state.dialog == dialog) {\n                    me.state.dialog = null;\n                    me.focus();\n                }\n                closed = true;\n                dialog.remove();\n                if (options.onClose)\n                    options.onClose(dialog);\n                var cm = me;\n                if (cm.state.vim) {\n                    cm.state.vim.status = null;\n                    cm.ace._signal(\"changeStatus\");\n                    cm.ace.renderer.$loop.schedule(cm.ace.renderer.CHANGE_CURSOR);\n                }\n            }\n        }\n        var inp = dialog.getElementsByTagName(\"input\")[0], button;\n        if (inp) {\n            if (options.value) {\n                inp.value = options.value;\n                if (options.selectValueOnOpen !== false)\n                    inp.select();\n            }\n            if (options.onInput)\n                CodeMirror.on(inp, \"input\", function (e) { options.onInput(e, inp.value, close); });\n            if (options.onKeyUp)\n                CodeMirror.on(inp, \"keyup\", function (e) { options.onKeyUp(e, inp.value, close); });\n            CodeMirror.on(inp, \"keydown\", function (e) {\n                if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) {\n                    return;\n                }\n                if (e.keyCode == 13)\n                    callback(inp.value);\n                if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {\n                    CodeMirror.e_stop(e);\n                    close();\n                }\n            });\n            if (options.closeOnBlur !== false)\n                CodeMirror.on(inp, \"blur\", close);\n            inp.focus();\n        }\n        else if (button = dialog.getElementsByTagName(\"button\")[0]) {\n            CodeMirror.on(button, \"click\", function () {\n                close();\n                me.focus();\n            });\n            if (options.closeOnBlur !== false)\n                CodeMirror.on(button, \"blur\", close);\n            button.focus();\n        }\n        return close;\n    });\n    CodeMirror.defineExtension(\"openNotification\", function (template, options) {\n        if (this.virtualSelectionMode())\n            return;\n        closeNotification(this, close);\n        var dialog = dialogDiv(this, template, options && options.bottom);\n        var closed = false, doneTimer;\n        var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n        function close() {\n            if (closed)\n                return;\n            closed = true;\n            clearTimeout(doneTimer);\n            dialog.remove();\n        }\n        CodeMirror.on(dialog, 'click', function (e) {\n            CodeMirror.e_preventDefault(e);\n            close();\n        });\n        if (duration)\n            doneTimer = setTimeout(close, duration);\n        return close;\n    });\n})();\nvar Pos = CodeMirror.Pos;\nfunction updateSelectionForSurrogateCharacters(cm, curStart, curEnd) {\n    if (curStart.line === curEnd.line && curStart.ch >= curEnd.ch - 1) {\n        var text = cm.getLine(curStart.line);\n        var charCode = text.charCodeAt(curStart.ch);\n        if (0xD800 <= charCode && charCode <= 0xD8FF) {\n            curEnd.ch += 1;\n        }\n    }\n    return { start: curStart, end: curEnd };\n}\nvar defaultKeymap = [\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: 'g<Up>', type: 'keyToKey', toKeys: 'gk' },\n    { keys: 'g<Down>', type: 'keyToKey', toKeys: 'gj' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Del>', type: 'keyToKey', toKeys: 'x' },\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>' }, // ipad keyboard sends C-Esc instead of C-[\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'keyToKey', toKeys: 'i', context: 'normal' },\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true } },\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true } },\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true } },\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false } },\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true } },\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true } },\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true } },\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true } },\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false } },\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false } },\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true } },\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true } },\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true } },\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false } },\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true } },\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true } },\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true } },\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true } },\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true } },\n    { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false } },\n    { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true } },\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true } },\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false } },\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true } },\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true } },\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true } },\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true } },\n    { keys: \"g$\", type: \"motion\", motion: \"moveToEndOfDisplayLine\" },\n    { keys: \"g^\", type: \"motion\", motion: \"moveToStartOfDisplayLine\" },\n    { keys: \"g0\", type: \"motion\", motion: \"moveToStartOfDisplayLine\" },\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar: true } },\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar: true } },\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar: true, repeatOffset: -1 } },\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true } },\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true } },\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true, inclusive: true } },\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false } },\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true } },\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false } },\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true } },\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false } },\n    { keys: '\\'<register>', type: 'motion', motion: 'goToMark', motionArgs: { toJumplist: true, linewise: true } },\n    { keys: '`<register>', type: 'motion', motion: 'goToMark', motionArgs: { toJumplist: true } },\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true } },\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true } },\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true } },\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true } },\n    { keys: '|', type: 'motion', motion: 'moveToColumn' },\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context: 'visual' },\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: { sameLine: true }, context: 'visual' },\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '=', type: 'operator', operator: 'indentAuto' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true } },\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false } },\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: { toLower: true }, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: { toLower: false }, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true } },\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true } },\n    { keys: 'gn', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: true } },\n    { keys: 'gN', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: false } },\n    { keys: 'gq', type: 'operator', operator: 'hardWrap' },\n    { keys: 'gw', type: 'operator', operator: 'hardWrap', operatorArgs: { keepCursor: true } },\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false } },\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true } },\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal' },\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual' },\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal' },\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual' },\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal' },\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual' },\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal' },\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual' },\n    { keys: '<C-u>', type: 'operatorMotion', operator: 'delete', motion: 'moveToStartOfLine', context: 'insert' },\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    { keys: '<C-w>', type: 'idle', context: 'normal' },\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true } },\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false } },\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true } },\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true } },\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'gi', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'lastEdit' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank' }, context: 'normal' },\n    { keys: 'gI', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'bol' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true } },\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true } },\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true } },\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'gJ', type: 'action', action: 'joinLines', actionArgs: { keepSpaces: true }, isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true } },\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true } },\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<register>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<register>', type: 'action', action: 'enterMacroRecordMode' },\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }, context: 'normal' },\n    { keys: 'R', type: 'operator', operator: 'change', operatorArgs: { linewise: true, fullLine: true }, context: 'visual', exitVisualBlock: true },\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: { toLower: true }, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: { toLower: false }, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<register>', type: 'action', action: 'setMark' },\n    { keys: '\"<register>', type: 'action', action: 'setRegister' },\n    { keys: '<C-r><register>', type: 'action', action: 'insertRegister', context: 'insert', isEdit: true },\n    { keys: '<C-o>', type: 'action', action: 'oneNormalCommand', context: 'insert' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' } },\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' } },\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' } },\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: { increase: true, backtrack: false } },\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: { increase: false, backtrack: false } },\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    { keys: 'a<register>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<register>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true } },\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true } },\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true } },\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true } },\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true } },\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true } },\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true } },\n    { keys: ':', type: 'ex' }\n];\nvar defaultKeymapLength = defaultKeymap.length;\nvar defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'omap', shortName: 'om' },\n    { name: 'noremap', shortName: 'no' },\n    { name: 'nnoremap', shortName: 'nn' },\n    { name: 'vnoremap', shortName: 'vn' },\n    { name: 'inoremap', shortName: 'ino' },\n    { name: 'onoremap', shortName: 'ono' },\n    { name: 'unmap' },\n    { name: 'mapclear', shortName: 'mapc' },\n    { name: 'nmapclear', shortName: 'nmapc' },\n    { name: 'vmapclear', shortName: 'vmapc' },\n    { name: 'imapclear', shortName: 'imapc' },\n    { name: 'omapclear', shortName: 'omapc' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'startinsert', shortName: 'start' },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'vglobal', shortName: 'v' },\n    { name: 'delete', shortName: 'd' },\n    { name: 'join', shortName: 'j' },\n    { name: 'normal', shortName: 'norm' },\n    { name: 'global', shortName: 'g' }\n];\nvar langmap = parseLangmap('');\nfunction enterVimMode(cm) {\n    cm.setOption('disableInput', true);\n    cm.setOption('showCursorWhenSelecting', false);\n    CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"normal\" });\n    cm.on('cursorActivity', onCursorActivity);\n    maybeInitVimState(cm);\n    CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n}\nfunction leaveVimMode(cm) {\n    cm.setOption('disableInput', false);\n    cm.off('cursorActivity', onCursorActivity);\n    CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    cm.state.vim = null;\n    if (highlightTimeout)\n        clearTimeout(highlightTimeout);\n}\nfunction getOnPasteFn(cm) {\n    var vim = cm.state.vim;\n    if (!vim.onPasteFn) {\n        vim.onPasteFn = function () {\n            if (!vim.insertMode) {\n                cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n                actions.enterInsertMode(cm, {}, vim);\n            }\n        };\n    }\n    return vim.onPasteFn;\n}\nvar numberRegex = /[\\d]/;\nvar wordCharTest = [CodeMirror.isWordChar, function (ch) {\n        return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function (ch) {\n        return /\\S/.test(ch);\n    }];\nvar validMarks = ['<', '>'];\nvar validRegisters = ['-', '\"', '.', ':', '_', '/', '+'];\nvar latinCharRegex = /^\\w$/;\nvar upperCaseChars;\ntry {\n    upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\");\n}\ncatch (_) {\n    upperCaseChars = /^[A-Z]$/;\n}\nfunction isLine(cm, line) {\n    return line >= cm.firstLine() && line <= cm.lastLine();\n}\nfunction isLowerCase(k) {\n    return (/^[a-z]$/).test(k);\n}\nfunction isMatchableSymbol(k) {\n    return '()[]{}'.indexOf(k) != -1;\n}\nfunction isNumber(k) {\n    return numberRegex.test(k);\n}\nfunction isUpperCase(k) {\n    return upperCaseChars.test(k);\n}\nfunction isWhiteSpaceString(k) {\n    return (/^\\s*$/).test(k);\n}\nfunction isEndOfSentenceSymbol(k) {\n    return '.?!'.indexOf(k) != -1;\n}\nfunction inArray(val, arr) {\n    for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n            return true;\n        }\n    }\n    return false;\n}\nvar options = {};\nfunction defineOption(name, defaultValue, type, aliases, callback) {\n    if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n    }\n    if (!type) {\n        type = 'string';\n    }\n    options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n    };\n    if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n            options[aliases[i]] = options[name];\n        }\n    }\n    if (defaultValue) {\n        setOption(name, defaultValue);\n    }\n}\nfunction setOption(name, value, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n        return new Error('Unknown option: ' + name);\n    }\n    if (option.type == 'boolean') {\n        if (value && value !== true) {\n            return new Error('Invalid argument: ' + name + '=' + value);\n        }\n        else if (value !== false) {\n            value = true;\n        }\n    }\n    if (option.callback) {\n        if (scope !== 'local') {\n            option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n            option.callback(value, cm);\n        }\n    }\n    else {\n        if (scope !== 'local') {\n            option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n            cm.state.vim.options[name] = { value: value };\n        }\n    }\n}\nfunction getOption(name, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n        return new Error('Unknown option: ' + name);\n    }\n    if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n            return local;\n        }\n        if (scope !== 'local') {\n            return option.callback();\n        }\n        return;\n    }\n    else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n    }\n}\ndefineOption('filetype', undefined, 'string', ['ft'], function (name, cm) {\n    if (cm === undefined) {\n        return;\n    }\n    if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n    }\n    else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n    }\n});\ndefineOption('textwidth', 80, 'number', ['tw'], function (width, cm) {\n    if (cm === undefined) {\n        return;\n    }\n    if (width === undefined) {\n        var value = cm.getOption('textwidth');\n        return value;\n    }\n    else {\n        var column = Math.round(width);\n        if (column > 1) {\n            cm.setOption('textwidth', column);\n        }\n    }\n});\nvar createCircularJumpList = function () {\n    var size = 100;\n    var pointer = -1;\n    var head = 0;\n    var tail = 0;\n    var buffer = new Array(size);\n    function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n            var next = ++pointer % size;\n            var trashMark = buffer[next];\n            if (trashMark) {\n                trashMark.clear();\n            }\n            buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n            var markPos = curMark.find();\n            if (markPos && !cursorEqual(markPos, oldCur)) {\n                useNextSlot(oldCur);\n            }\n        }\n        else {\n            useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n            tail = 0;\n        }\n    }\n    function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n            pointer = head;\n        }\n        else if (pointer < tail) {\n            pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        if (mark && !mark.find()) {\n            var inc = offset > 0 ? 1 : -1;\n            var newCur;\n            var oldCur = cm.getCursor();\n            do {\n                pointer += inc;\n                mark = buffer[(size + pointer) % size];\n                if (mark &&\n                    (newCur = mark.find()) &&\n                    !cursorEqual(oldCur, newCur)) {\n                    break;\n                }\n            } while (pointer < head && pointer > tail);\n        }\n        return mark;\n    }\n    function find(cm, offset) {\n        var oldPointer = pointer;\n        var mark = move(cm, offset);\n        pointer = oldPointer;\n        return mark && mark.find();\n    }\n    return {\n        cachedCursor: undefined, //used for # and * jumps\n        add: add,\n        find: find,\n        move: move\n    };\n};\nvar createInsertModeChanges = function (c) {\n    if (c) {\n        return {\n            changes: c.changes,\n            expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n    }\n    return {\n        changes: [],\n        expectCursorActivityForChange: false\n    };\n};\nfunction MacroModeState() {\n    this.latestRegister = undefined;\n    this.isPlaying = false;\n    this.isRecording = false;\n    this.replaySearchQueries = [];\n    this.onRecordingDone = undefined;\n    this.lastInsertModeChanges = createInsertModeChanges();\n}\nMacroModeState.prototype = {\n    exitMacroRecordMode: function () {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n            macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n    },\n    enterMacroRecordMode: function (cm, registerName) {\n        var register = vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n            register.clear();\n            this.latestRegister = registerName;\n            if (cm.openDialog) {\n                var template = dom('span', { class: 'cm-vim-message' }, 'recording @' + registerName);\n                this.onRecordingDone = cm.openDialog(template, null, { bottom: true });\n            }\n            this.isRecording = true;\n        }\n    }\n};\nfunction maybeInitVimState(cm) {\n    if (!cm.state.vim) {\n        cm.state.vim = {\n            inputState: new InputState(),\n            lastEditInputState: undefined,\n            lastEditActionCommand: undefined,\n            lastHPos: -1,\n            lastHSPos: -1,\n            lastMotion: null,\n            marks: {},\n            insertMode: false,\n            insertModeReturn: false,\n            insertModeRepeat: undefined,\n            visualMode: false,\n            visualLine: false,\n            visualBlock: false,\n            lastSelection: null,\n            lastPastedText: null,\n            sel: {},\n            options: {},\n            expectLiteralNext: false\n        };\n    }\n    return cm.state.vim;\n}\nvar vimGlobalState;\nfunction resetVimGlobalState() {\n    vimGlobalState = {\n        searchQuery: null,\n        searchIsReversed: false,\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        lastCharacterSearch: { increment: 0, forward: true, selectedCharacter: '' },\n        registerController: new RegisterController({}),\n        searchHistoryController: new HistoryController(),\n        exCommandHistoryController: new HistoryController()\n    };\n    for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n    }\n}\nvar lastInsertModeKeyTimer;\nvar vimApi = {\n    enterVimMode: enterVimMode,\n    leaveVimMode: leaveVimMode,\n    buildKeyMap: function () {\n    },\n    getRegisterController: function () {\n        return vimGlobalState.registerController;\n    },\n    resetVimGlobalState_: resetVimGlobalState,\n    getVimGlobalState_: function () {\n        return vimGlobalState;\n    },\n    maybeInitVimState_: maybeInitVimState,\n    suppressErrorLogging: false,\n    InsertModeKey: InsertModeKey,\n    map: function (lhs, rhs, ctx) {\n        exCommandDispatcher.map(lhs, rhs, ctx);\n    },\n    unmap: function (lhs, ctx) {\n        return exCommandDispatcher.unmap(lhs, ctx);\n    },\n    noremap: function (lhs, rhs, ctx) {\n        exCommandDispatcher.map(lhs, rhs, ctx, true);\n    },\n    mapclear: function (ctx) {\n        var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;\n        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n        defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n        if (ctx) {\n            for (var i = userKeymap.length - 1; i >= 0; i--) {\n                var mapping = userKeymap[i];\n                if (ctx !== mapping.context) {\n                    if (mapping.context) {\n                        this._mapCommand(mapping);\n                    }\n                    else {\n                        var contexts = ['normal', 'insert', 'visual'];\n                        for (var j in contexts) {\n                            if (contexts[j] !== ctx) {\n                                var newMapping = {};\n                                for (var key in mapping) {\n                                    newMapping[key] = mapping[key];\n                                }\n                                newMapping.context = contexts[j];\n                                this._mapCommand(newMapping);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    },\n    langmap: updateLangmap,\n    vimKeyFromEvent: vimKeyFromEvent,\n    setOption: setOption,\n    getOption: getOption,\n    defineOption: defineOption,\n    defineEx: function (name, prefix, func) {\n        if (!prefix) {\n            prefix = name;\n        }\n        else if (name.indexOf(prefix) !== 0) {\n            throw new Error('(Vim.defineEx) \"' + prefix + '\" is not a prefix of \"' + name + '\", command not registered');\n        }\n        exCommands[name] = func;\n        exCommandDispatcher.commandMap_[prefix] = { name: name, shortName: prefix, type: 'api' };\n    },\n    handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n            return command();\n        }\n    },\n    multiSelectHandleKey: multiSelectHandleKey,\n    findKey: function (cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isRecording) {\n                if (key == 'q') {\n                    macroModeState.exitMacroRecordMode();\n                    clearInputState(cm);\n                    return true;\n                }\n                if (origin != 'mapping') {\n                    logKey(macroModeState, key);\n                }\n            }\n        }\n        function handleEsc() {\n            if (key == '<Esc>') {\n                if (vim.visualMode) {\n                    exitVisualMode(cm);\n                }\n                else if (vim.insertMode) {\n                    exitInsertMode(cm);\n                }\n                else {\n                    return;\n                }\n                clearInputState(cm);\n                return true;\n            }\n        }\n        function handleKeyInsertMode() {\n            if (handleEsc()) {\n                return true;\n            }\n            vim.inputState.keyBuffer.push(key);\n            var keys = vim.inputState.keyBuffer.join(\"\");\n            var keysAreChars = key.length == 1;\n            var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n            var changeQueue = vim.inputState.changeQueue;\n            if (match.type == 'none') {\n                clearInputState(cm);\n                return false;\n            }\n            else if (match.type == 'partial') {\n                if (match.expectLiteralNext)\n                    vim.expectLiteralNext = true;\n                if (lastInsertModeKeyTimer) {\n                    window.clearTimeout(lastInsertModeKeyTimer);\n                }\n                lastInsertModeKeyTimer = keysAreChars && window.setTimeout(function () { if (vim.insertMode && vim.inputState.keyBuffer.length) {\n                    clearInputState(cm);\n                } }, getOption('insertModeEscKeysTimeout'));\n                if (keysAreChars) {\n                    var selections = cm.listSelections();\n                    if (!changeQueue || changeQueue.removed.length != selections.length)\n                        changeQueue = vim.inputState.changeQueue = new ChangeQueue;\n                    changeQueue.inserted += key;\n                    for (var i = 0; i < selections.length; i++) {\n                        var from = cursorMin(selections[i].anchor, selections[i].head);\n                        var to = cursorMax(selections[i].anchor, selections[i].head);\n                        var text = cm.getRange(from, cm.state.overwrite ? offsetCursor(to, 0, 1) : to);\n                        changeQueue.removed[i] = (changeQueue.removed[i] || \"\") + text;\n                    }\n                }\n                return !keysAreChars;\n            }\n            vim.expectLiteralNext = false;\n            if (lastInsertModeKeyTimer) {\n                window.clearTimeout(lastInsertModeKeyTimer);\n            }\n            if (match.command && changeQueue) {\n                var selections = cm.listSelections();\n                for (var i = 0; i < selections.length; i++) {\n                    var here = selections[i].head;\n                    cm.replaceRange(changeQueue.removed[i] || \"\", offsetCursor(here, 0, -changeQueue.inserted.length), here, '+input');\n                }\n                vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n            }\n            if (!match.command)\n                clearInputState(cm);\n            return match.command;\n        }\n        function handleKeyNonInsertMode() {\n            if (handleMacroRecording() || handleEsc()) {\n                return true;\n            }\n            vim.inputState.keyBuffer.push(key);\n            var keys = vim.inputState.keyBuffer.join(\"\");\n            if (/^[1-9]\\d*$/.test(keys)) {\n                return true;\n            }\n            var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n            if (!keysMatcher) {\n                clearInputState(cm);\n                return false;\n            }\n            var context = vim.visualMode ? 'visual' :\n                'normal';\n            var mainKey = keysMatcher[2] || keysMatcher[1];\n            if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n                mainKey = vim.inputState.operatorShortcut;\n            }\n            var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n            if (match.type == 'none') {\n                clearInputState(cm);\n                return false;\n            }\n            else if (match.type == 'partial') {\n                if (match.expectLiteralNext)\n                    vim.expectLiteralNext = true;\n                return true;\n            }\n            else if (match.type == 'clear') {\n                clearInputState(cm);\n                return true;\n            }\n            vim.expectLiteralNext = false;\n            vim.inputState.keyBuffer.length = 0;\n            keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n            if (keysMatcher[1] && keysMatcher[1] != '0') {\n                vim.inputState.pushRepeatDigit(keysMatcher[1]);\n            }\n            return match.command;\n        }\n        var command;\n        if (vim.insertMode) {\n            command = handleKeyInsertMode();\n        }\n        else {\n            command = handleKeyNonInsertMode();\n        }\n        if (command === false) {\n            return !vim.insertMode && key.length === 1 ? function () { return true; } : undefined;\n        }\n        else if (command === true) {\n            return function () { return true; };\n        }\n        else {\n            return function () {\n                if ((command.operator || command.isEdit) && cm.getOption('readOnly'))\n                    return; // ace_patch\n                return cm.operation(function () {\n                    cm.curOp.isVimOp = true;\n                    try {\n                        if (command.type == 'keyToKey') {\n                            doKeyToKey(cm, command.toKeys, command);\n                        }\n                        else {\n                            commandDispatcher.processCommand(cm, vim, command);\n                        }\n                    }\n                    catch (e) {\n                        cm.state.vim = undefined;\n                        maybeInitVimState(cm);\n                        if (!vimApi.suppressErrorLogging) {\n                            console['log'](e);\n                        }\n                        throw e;\n                    }\n                    return true;\n                });\n            };\n        }\n    },\n    handleEx: function (cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n    },\n    defineMotion: defineMotion,\n    defineAction: defineAction,\n    defineOperator: defineOperator,\n    mapCommand: mapCommand,\n    _mapCommand: _mapCommand,\n    defineRegister: defineRegister,\n    exitVisualMode: exitVisualMode,\n    exitInsertMode: exitInsertMode\n};\nvar keyToKeyStack = [];\nvar noremap = false;\nvar virtualPrompt;\nfunction sendKeyToPrompt(key) {\n    if (key[0] == \"<\") {\n        var lowerKey = key.toLowerCase().slice(1, -1);\n        var parts = lowerKey.split('-');\n        lowerKey = parts.pop() || '';\n        if (lowerKey == 'lt')\n            key = '<';\n        else if (lowerKey == 'space')\n            key = ' ';\n        else if (lowerKey == 'cr')\n            key = '\\n';\n        else if (vimToCmKeyMap[lowerKey]) {\n            var value = virtualPrompt.value;\n            var event = {\n                key: vimToCmKeyMap[lowerKey],\n                target: {\n                    value: value,\n                    selectionEnd: value.length,\n                    selectionStart: value.length\n                }\n            };\n            if (virtualPrompt.onKeyDown) {\n                virtualPrompt.onKeyDown(event, virtualPrompt.value, close);\n            }\n            if (virtualPrompt && virtualPrompt.onKeyUp) {\n                virtualPrompt.onKeyUp(event, virtualPrompt.value, close);\n            }\n            return;\n        }\n    }\n    if (key == '\\n') {\n        var prompt = virtualPrompt;\n        virtualPrompt = null;\n        prompt.onClose && prompt.onClose(prompt.value);\n    }\n    else {\n        virtualPrompt.value = (virtualPrompt.value || '') + key;\n    }\n    function close(value) {\n        if (typeof value == 'string') {\n            virtualPrompt.value = value;\n        }\n        else {\n            virtualPrompt = null;\n        }\n    }\n}\nfunction doKeyToKey(cm, keys, fromKey) {\n    var noremapBefore = noremap;\n    if (fromKey) {\n        if (keyToKeyStack.indexOf(fromKey) != -1)\n            return;\n        keyToKeyStack.push(fromKey);\n        noremap = fromKey.noremap != false;\n    }\n    try {\n        var vim = maybeInitVimState(cm);\n        var keyRe = /<(?:[CSMA]-)*\\w+>|./gi;\n        var match;\n        while ((match = keyRe.exec(keys))) {\n            var key = match[0];\n            var wasInsert = vim.insertMode;\n            if (virtualPrompt) {\n                sendKeyToPrompt(key);\n                continue;\n            }\n            var result = vimApi.handleKey(cm, key, 'mapping');\n            if (!result && wasInsert && vim.insertMode) {\n                if (key[0] == \"<\") {\n                    var lowerKey = key.toLowerCase().slice(1, -1);\n                    var parts = lowerKey.split('-');\n                    lowerKey = parts.pop() || '';\n                    if (lowerKey == 'lt')\n                        key = '<';\n                    else if (lowerKey == 'space')\n                        key = ' ';\n                    else if (lowerKey == 'cr')\n                        key = '\\n';\n                    else if (vimToCmKeyMap.hasOwnProperty(lowerKey)) {\n                        key = vimToCmKeyMap[lowerKey];\n                        sendCmKey(cm, key);\n                        continue;\n                    }\n                    else {\n                        key = key[0];\n                        keyRe.lastIndex = match.index + 1;\n                    }\n                }\n                cm.replaceSelection(key);\n            }\n        }\n    }\n    finally {\n        keyToKeyStack.pop();\n        noremap = keyToKeyStack.length ? noremapBefore : false;\n        if (!keyToKeyStack.length && virtualPrompt) {\n            var promptOptions = virtualPrompt;\n            virtualPrompt = null;\n            showPrompt(cm, promptOptions);\n        }\n    }\n}\nvar specialKey = {\n    Return: 'CR', Backspace: 'BS', 'Delete': 'Del', Escape: 'Esc', Insert: 'Ins',\n    ArrowLeft: 'Left', ArrowRight: 'Right', ArrowUp: 'Up', ArrowDown: 'Down',\n    Enter: 'CR', ' ': 'Space'\n};\nvar ignoredKeys = { Shift: 1, Alt: 1, Command: 1, Control: 1,\n    CapsLock: 1, AltGraph: 1, Dead: 1, Unidentified: 1 };\nvar vimToCmKeyMap = {};\n'Left|Right|Up|Down|End|Home'.split('|').concat(Object.keys(specialKey)).forEach(function (x) {\n    vimToCmKeyMap[(specialKey[x] || '').toLowerCase()]\n        = vimToCmKeyMap[x.toLowerCase()] = x;\n});\nfunction vimKeyFromEvent(e, vim) {\n    var key = e.key;\n    if (ignoredKeys[key])\n        return;\n    if (key.length > 1 && key[0] == \"n\") {\n        key = key.replace(\"Numpad\", \"\");\n    }\n    key = specialKey[key] || key;\n    var name = '';\n    if (e.ctrlKey) {\n        name += 'C-';\n    }\n    if (e.altKey) {\n        name += 'A-';\n    }\n    if (e.metaKey) {\n        name += 'M-';\n    }\n    if (CodeMirror.isMac && e.altKey && !e.metaKey && !e.ctrlKey) {\n        name = name.slice(2);\n    }\n    if ((name || key.length > 1) && e.shiftKey) {\n        name += 'S-';\n    }\n    if (vim && !vim.expectLiteralNext && key.length == 1) {\n        if (langmap.keymap && key in langmap.keymap) {\n            if (langmap.remapCtrl != false || !name)\n                key = langmap.keymap[key];\n        }\n        else if (key.charCodeAt(0) > 255) {\n            var code = e.code && e.code.slice(-1) || \"\";\n            if (!e.shiftKey)\n                code = code.toLowerCase();\n            if (code)\n                key = code;\n        }\n    }\n    name += key;\n    if (name.length > 1) {\n        name = '<' + name + '>';\n    }\n    return name;\n}\n;\nfunction updateLangmap(langmapString, remapCtrl) {\n    if (langmap.string !== langmapString) {\n        langmap = parseLangmap(langmapString);\n    }\n    langmap.remapCtrl = remapCtrl;\n}\nfunction parseLangmap(langmapString) {\n    var keymap = {};\n    if (!langmapString)\n        return { keymap: keymap, string: '' };\n    function getEscaped(list) {\n        return list.split(/\\\\?(.)/).filter(Boolean);\n    }\n    langmapString.split(/((?:[^\\\\,]|\\\\.)+),/).map(function (part) {\n        if (!part)\n            return;\n        var semicolon = part.split(/((?:[^\\\\;]|\\\\.)+);/);\n        if (semicolon.length == 3) {\n            var from = getEscaped(semicolon[1]);\n            var to = getEscaped(semicolon[2]);\n            if (from.length !== to.length)\n                return; // skip over malformed part\n            for (var i = 0; i < from.length; ++i)\n                keymap[from[i]] = to[i];\n        }\n        else if (semicolon.length == 1) {\n            var pairs = getEscaped(part);\n            if (pairs.length % 2 !== 0)\n                return; // skip over malformed part\n            for (var i = 0; i < pairs.length; i += 2)\n                keymap[pairs[i]] = pairs[i + 1];\n        }\n    });\n    return { keymap: keymap, string: langmapString };\n}\ndefineOption('langmap', undefined, 'string', ['lmap'], function (name, cm) {\n    if (name === undefined) {\n        return langmap.string;\n    }\n    else {\n        updateLangmap(name);\n    }\n});\nfunction InputState() {\n    this.prefixRepeat = [];\n    this.motionRepeat = [];\n    this.operator = null;\n    this.operatorArgs = null;\n    this.motion = null;\n    this.motionArgs = null;\n    this.keyBuffer = []; // For matching multi-key commands.\n    this.registerName = null; // Defaults to the unnamed register.\n    this.changeQueue = null; // For restoring text used by insert mode keybindings\n}\nInputState.prototype.pushRepeatDigit = function (n) {\n    if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n    }\n    else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n    }\n};\nInputState.prototype.getRepeat = function () {\n    var repeat = 0;\n    if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n            repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n            repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n    }\n    return repeat;\n};\nfunction clearInputState(cm, reason) {\n    cm.state.vim.inputState = new InputState();\n    cm.state.vim.expectLiteralNext = false;\n    CodeMirror.signal(cm, 'vim-command-done', reason);\n}\nfunction ChangeQueue() {\n    this.removed = [];\n    this.inserted = \"\";\n}\nfunction Register(text, linewise, blockwise) {\n    this.clear();\n    this.keyBuffer = [text || ''];\n    this.insertModeChanges = [];\n    this.searchQueries = [];\n    this.linewise = !!linewise;\n    this.blockwise = !!blockwise;\n}\nRegister.prototype = {\n    setText: function (text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n    },\n    pushText: function (text, linewise) {\n        if (linewise) {\n            if (!this.linewise) {\n                this.keyBuffer.push('\\n');\n            }\n            this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n    },\n    pushInsertModeChanges: function (changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n    },\n    pushSearchQuery: function (query) {\n        this.searchQueries.push(query);\n    },\n    clear: function () {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n    },\n    toString: function () {\n        return this.keyBuffer.join('');\n    }\n};\nfunction defineRegister(name, register) {\n    var registers = vimGlobalState.registerController.registers;\n    if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n    }\n    registers[name] = register;\n    validRegisters.push(name);\n}\nfunction RegisterController(registers) {\n    this.registers = registers;\n    this.unnamedRegister = registers['\"'] = new Register();\n    registers['.'] = new Register();\n    registers[':'] = new Register();\n    registers['/'] = new Register();\n    registers['+'] = new Register();\n}\nRegisterController.prototype = {\n    pushText: function (registerName, operator, text, linewise, blockwise) {\n        if (registerName === '_')\n            return;\n        if (linewise && text.charAt(text.length - 1) !== '\\n') {\n            text += '\\n';\n        }\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        if (!register) {\n            switch (operator) {\n                case 'yank':\n                    this.registers['0'] = new Register(text, linewise, blockwise);\n                    break;\n                case 'delete':\n                case 'change':\n                    if (text.indexOf('\\n') == -1) {\n                        this.registers['-'] = new Register(text, linewise);\n                    }\n                    else {\n                        this.shiftNumericRegisters_();\n                        this.registers['1'] = new Register(text, linewise);\n                    }\n                    break;\n            }\n            this.unnamedRegister.setText(text, linewise, blockwise);\n            return;\n        }\n        var append = isUpperCase(registerName);\n        if (append) {\n            register.pushText(text, linewise);\n        }\n        else {\n            register.setText(text, linewise, blockwise);\n        }\n        if (registerName === '+' && typeof navigator !== 'undefined' &&\n            typeof navigator.clipboard !== 'undefined' &&\n            typeof navigator.clipboard.readText === 'function') {\n            navigator.clipboard.writeText(text);\n        }\n        this.unnamedRegister.setText(register.toString(), linewise);\n    },\n    getRegister: function (name) {\n        if (!this.isValidRegister(name)) {\n            return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n            this.registers[name] = new Register();\n        }\n        return this.registers[name];\n    },\n    isValidRegister: function (name) {\n        return name && (inArray(name, validRegisters) || latinCharRegex.test(name));\n    },\n    shiftNumericRegisters_: function () {\n        for (var i = 9; i >= 2; i--) {\n            this.registers[i] = this.getRegister('' + (i - 1));\n        }\n    }\n};\nfunction HistoryController() {\n    this.historyBuffer = [];\n    this.iterator = 0;\n    this.initialPrefix = null;\n}\nHistoryController.prototype = {\n    nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null)\n            this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i += dir) {\n            var element = historyBuffer[i];\n            for (var j = 0; j <= element.length; j++) {\n                if (this.initialPrefix == element.substring(0, j)) {\n                    this.iterator = i;\n                    return element;\n                }\n            }\n        }\n        if (i >= historyBuffer.length) {\n            this.iterator = historyBuffer.length;\n            return this.initialPrefix;\n        }\n        if (i < 0)\n            return input;\n    },\n    pushInput: function (input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1)\n            this.historyBuffer.splice(index, 1);\n        if (input.length)\n            this.historyBuffer.push(input);\n    },\n    reset: function () {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n    }\n};\nvar commandDispatcher = {\n    matchCommand: function (keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n            return { type: 'none' };\n        }\n        else if (!matches.full && matches.partial) {\n            return {\n                type: 'partial',\n                expectLiteralNext: matches.partial.length == 1 && matches.partial[0].keys.slice(-11) == '<character>' // langmap literal logic\n            };\n        }\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n            var match = matches.full[i];\n            if (!bestMatch) {\n                bestMatch = match;\n            }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>' || bestMatch.keys.slice(-10) == '<register>') {\n            var character = lastChar(keys);\n            if (!character || character.length > 1)\n                return { type: 'clear' };\n            inputState.selectedCharacter = character;\n        }\n        return { type: 'full', command: bestMatch };\n    },\n    processCommand: function (cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n            case 'motion':\n                this.processMotion(cm, vim, command);\n                break;\n            case 'operator':\n                this.processOperator(cm, vim, command);\n                break;\n            case 'operatorMotion':\n                this.processOperatorMotion(cm, vim, command);\n                break;\n            case 'action':\n                this.processAction(cm, vim, command);\n                break;\n            case 'search':\n                this.processSearch(cm, vim, command);\n                break;\n            case 'ex':\n            case 'keyToEx':\n                this.processEx(cm, vim, command);\n                break;\n            default:\n                break;\n        }\n    },\n    processMotion: function (cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n    },\n    processOperator: function (cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n            if (inputState.operator == command.operator) {\n                inputState.motion = 'expandToLine';\n                inputState.motionArgs = { linewise: true };\n                this.evalInput(cm, vim);\n                return;\n            }\n            else {\n                clearInputState(cm);\n            }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (command.keys.length > 1) {\n            inputState.operatorShortcut = command.keys;\n        }\n        if (command.exitVisualBlock) {\n            vim.visualBlock = false;\n            updateCmSelection(cm);\n        }\n        if (vim.visualMode) {\n            this.evalInput(cm, vim);\n        }\n    },\n    processOperatorMotion: function (cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n            if (visualMode && operatorMotionArgs.visualLine) {\n                vim.visualLine = true;\n            }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n            this.processMotion(cm, vim, command);\n        }\n    },\n    processAction: function (cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n            actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        if (command.operator) {\n            this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n            this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n            this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n            this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n    },\n    processSearch: function (cm, vim, command) {\n        if (!cm.getSearchCursor) {\n            return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            try {\n                updateSearchQuery(cm, query, ignoreCase, smartCase);\n            }\n            catch (e) {\n                showConfirm(cm, 'Invalid regex: ' + query);\n                clearInputState(cm);\n                return;\n            }\n            commandDispatcher.processMotion(cm, vim, {\n                type: 'motion',\n                motion: 'findNext',\n                motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n            });\n        }\n        function onPromptClose(query) {\n            handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isRecording) {\n                logSearchQuery(macroModeState, query);\n            }\n        }\n        function onPromptKeyUp(e, query, close) {\n            var keyName = vimKeyFromEvent(e), up, offset;\n            if (keyName == '<Up>' || keyName == '<Down>') {\n                up = keyName == '<Up>' ? true : false;\n                offset = e.target ? e.target.selectionEnd : 0;\n                query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n                close(query);\n                if (offset && e.target)\n                    e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n            }\n            else if (keyName && keyName != '<Left>' && keyName != '<Right>') {\n                vimGlobalState.searchHistoryController.reset();\n            }\n            var parsedQuery;\n            try {\n                parsedQuery = updateSearchQuery(cm, query, true /** ignoreCase */, true /** smartCase */);\n            }\n            catch (e) {\n            }\n            if (parsedQuery) {\n                cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n            }\n            else {\n                clearSearchHighlight(cm);\n                cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            }\n        }\n        function onPromptKeyDown(e, query, close) {\n            var keyName = vimKeyFromEvent(e);\n            if (keyName == '<Esc>' || keyName == '<C-c>' || keyName == '<C-[>' ||\n                (keyName == '<BS>' && query == '')) {\n                vimGlobalState.searchHistoryController.pushInput(query);\n                vimGlobalState.searchHistoryController.reset();\n                updateSearchQuery(cm, originalQuery);\n                clearSearchHighlight(cm);\n                cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n                CodeMirror.e_stop(e);\n                clearInputState(cm);\n                close();\n                cm.focus();\n            }\n            else if (keyName == '<Up>' || keyName == '<Down>') {\n                CodeMirror.e_stop(e);\n            }\n            else if (keyName == '<C-u>') {\n                CodeMirror.e_stop(e);\n                close('');\n            }\n        }\n        switch (command.searchArgs.querySrc) {\n            case 'prompt':\n                var macroModeState = vimGlobalState.macroModeState;\n                if (macroModeState.isPlaying) {\n                    var query = macroModeState.replaySearchQueries.shift();\n                    handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n                }\n                else {\n                    showPrompt(cm, {\n                        onClose: onPromptClose,\n                        prefix: promptPrefix,\n                        desc: '(JavaScript regexp)',\n                        onKeyUp: onPromptKeyUp,\n                        onKeyDown: onPromptKeyDown\n                    });\n                }\n                break;\n            case 'wordUnderCursor':\n                var word = expandWordUnderCursor(cm, { noSymbol: true });\n                var isKeyword = true;\n                if (!word) {\n                    word = expandWordUnderCursor(cm, { noSymbol: false });\n                    isKeyword = false;\n                }\n                if (!word) {\n                    showConfirm(cm, 'No word under cursor');\n                    clearInputState(cm);\n                    return;\n                }\n                var query = cm.getLine(word.start.line).substring(word.start.ch, word.end.ch);\n                if (isKeyword && wholeWordOnly) {\n                    query = '\\\\b' + query + '\\\\b';\n                }\n                else {\n                    query = escapeRegex(query);\n                }\n                vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n                cm.setCursor(word.start);\n                handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n                break;\n        }\n    },\n    processEx: function (cm, vim, command) {\n        function onPromptClose(input) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            exCommandDispatcher.processCommand(cm, input);\n            if (cm.state.vim)\n                clearInputState(cm);\n        }\n        function onPromptKeyDown(e, input, close) {\n            var keyName = vimKeyFromEvent(e), up, offset;\n            if (keyName == '<Esc>' || keyName == '<C-c>' || keyName == '<C-[>' ||\n                (keyName == '<BS>' && input == '')) {\n                vimGlobalState.exCommandHistoryController.pushInput(input);\n                vimGlobalState.exCommandHistoryController.reset();\n                CodeMirror.e_stop(e);\n                clearInputState(cm);\n                close();\n                cm.focus();\n            }\n            if (keyName == '<Up>' || keyName == '<Down>') {\n                CodeMirror.e_stop(e);\n                up = keyName == '<Up>' ? true : false;\n                offset = e.target ? e.target.selectionEnd : 0;\n                input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n                close(input);\n                if (offset && e.target)\n                    e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n            }\n            else if (keyName == '<C-u>') {\n                CodeMirror.e_stop(e);\n                close('');\n            }\n            else if (keyName && keyName != '<Left>' && keyName != '<Right>') {\n                vimGlobalState.exCommandHistoryController.reset();\n            }\n        }\n        if (command.type == 'keyToEx') {\n            exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        }\n        else {\n            if (vim.visualMode) {\n                showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                    onKeyDown: onPromptKeyDown, selectValueOnOpen: false });\n            }\n            else {\n                showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                    onKeyDown: onPromptKeyDown });\n            }\n        }\n    },\n    evalInput: function (cm, vim) {\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head) : cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n            this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n            repeat = inputState.repeatOverride;\n        }\n        else {\n            repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n            motionArgs.repeatIsExplicit = true;\n        }\n        else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n            repeat = 1;\n            motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n            motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n                inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n            var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n            vim.lastMotion = motions[motion];\n            if (!motionResult) {\n                return;\n            }\n            if (motionArgs.toJumplist) {\n                if (!operator && cm.ace.curOp != null)\n                    cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\n                var jumpList = vimGlobalState.jumpList;\n                var cachedCursor = jumpList.cachedCursor;\n                if (cachedCursor) {\n                    recordJumpPosition(cm, cachedCursor, motionResult);\n                    delete jumpList.cachedCursor;\n                }\n                else {\n                    recordJumpPosition(cm, origHead, motionResult);\n                }\n            }\n            if (motionResult instanceof Array) {\n                newAnchor = motionResult[0];\n                newHead = motionResult[1];\n            }\n            else {\n                newHead = motionResult;\n            }\n            if (!newHead) {\n                newHead = copyCursor(origHead);\n            }\n            if (vim.visualMode) {\n                if (!(vim.visualBlock && newHead.ch === Infinity)) {\n                    newHead = clipCursorToContent(cm, newHead, oldHead);\n                }\n                if (newAnchor) {\n                    newAnchor = clipCursorToContent(cm, newAnchor);\n                }\n                newAnchor = newAnchor || oldAnchor;\n                sel.anchor = newAnchor;\n                sel.head = newHead;\n                updateCmSelection(cm);\n                updateMark(cm, vim, '<', cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n                updateMark(cm, vim, '>', cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n            }\n            else if (!operator) {\n                if (cm.ace.curOp)\n                    cm.ace.curOp.vimDialogScroll = \"center-animate\"; // ace_patch\n                newHead = clipCursorToContent(cm, newHead, oldHead);\n                cm.setCursor(newHead.line, newHead.ch);\n            }\n        }\n        if (operator) {\n            if (operatorArgs.lastSel) {\n                newAnchor = oldAnchor;\n                var lastSel = operatorArgs.lastSel;\n                var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n                var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n                if (lastSel.visualLine) {\n                    newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n                }\n                else if (lastSel.visualBlock) {\n                    newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n                }\n                else if (lastSel.head.line == lastSel.anchor.line) {\n                    newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n                }\n                else {\n                    newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n                }\n                vim.visualMode = true;\n                vim.visualLine = lastSel.visualLine;\n                vim.visualBlock = lastSel.visualBlock;\n                sel = vim.sel = {\n                    anchor: newAnchor,\n                    head: newHead\n                };\n                updateCmSelection(cm);\n            }\n            else if (vim.visualMode) {\n                operatorArgs.lastSel = {\n                    anchor: copyCursor(sel.anchor),\n                    head: copyCursor(sel.head),\n                    visualBlock: vim.visualBlock,\n                    visualLine: vim.visualLine\n                };\n            }\n            var curStart, curEnd, linewise, mode;\n            var cmSel;\n            if (vim.visualMode) {\n                curStart = cursorMin(sel.head, sel.anchor);\n                curEnd = cursorMax(sel.head, sel.anchor);\n                linewise = vim.visualLine || operatorArgs.linewise;\n                mode = vim.visualBlock ? 'block' :\n                    linewise ? 'line' :\n                        'char';\n                var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n                cmSel = makeCmSelection(cm, {\n                    anchor: newPositions.start,\n                    head: newPositions.end\n                }, mode);\n                if (linewise) {\n                    var ranges = cmSel.ranges;\n                    if (mode == 'block') {\n                        for (var i = 0; i < ranges.length; i++) {\n                            ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                        }\n                    }\n                    else if (mode == 'line') {\n                        ranges[0].head = new Pos(ranges[0].head.line + 1, 0);\n                    }\n                }\n            }\n            else {\n                curStart = copyCursor(newAnchor || oldAnchor);\n                curEnd = copyCursor(newHead || oldHead);\n                if (cursorIsBefore(curEnd, curStart)) {\n                    var tmp = curStart;\n                    curStart = curEnd;\n                    curEnd = tmp;\n                }\n                linewise = motionArgs.linewise || operatorArgs.linewise;\n                if (linewise) {\n                    expandSelectionToLine(cm, curStart, curEnd);\n                }\n                else if (motionArgs.forward) {\n                    clipToLine(cm, curStart, curEnd);\n                }\n                mode = 'char';\n                var exclusive = !motionArgs.inclusive || linewise;\n                var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n                cmSel = makeCmSelection(cm, {\n                    anchor: newPositions.start,\n                    head: newPositions.end\n                }, mode, exclusive);\n            }\n            cm.setSelections(cmSel.ranges, cmSel.primary);\n            vim.lastMotion = null;\n            operatorArgs.repeat = repeat; // For indent in visual mode.\n            operatorArgs.registerName = registerName;\n            operatorArgs.linewise = linewise;\n            var operatorMoveTo = operators[operator](cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n            if (vim.visualMode) {\n                exitVisualMode(cm, operatorMoveTo != null);\n            }\n            if (operatorMoveTo) {\n                cm.setCursor(operatorMoveTo);\n            }\n        }\n    },\n    recordLastEdit: function (vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) {\n            return;\n        }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n        macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n    }\n};\nvar motions = {\n    moveToTopLine: function (cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat - 1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToMiddleLine: function (cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToBottomLine: function (cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    expandToLine: function (_cm, head, motionArgs) {\n        var cur = head;\n        return new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    },\n    findNext: function (cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n            return;\n        }\n        var prev = !motionArgs.forward;\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev /** prev */, query, motionArgs.repeat);\n    },\n    findAndSelectNextInclusive: function (cm, _head, motionArgs, vim, prevInputState) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n            return;\n        }\n        var prev = !motionArgs.forward;\n        prev = (state.isReversed()) ? !prev : prev;\n        var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);\n        if (!next) {\n            return;\n        }\n        if (prevInputState.operator) {\n            return next;\n        }\n        var from = next[0];\n        var to = new Pos(next[1].line, next[1].ch - 1);\n        if (vim.visualMode) {\n            if (vim.visualLine || vim.visualBlock) {\n                vim.visualLine = false;\n                vim.visualBlock = false;\n                CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"visual\", subMode: \"\" });\n            }\n            var anchor = vim.sel.anchor;\n            if (anchor) {\n                if (state.isReversed()) {\n                    if (motionArgs.forward) {\n                        return [anchor, from];\n                    }\n                    return [anchor, to];\n                }\n                else {\n                    if (motionArgs.forward) {\n                        return [anchor, to];\n                    }\n                    return [anchor, from];\n                }\n            }\n        }\n        else {\n            vim.visualMode = true;\n            vim.visualLine = false;\n            vim.visualBlock = false;\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"visual\", subMode: \"\" });\n        }\n        return prev ? [to, from] : [from, to];\n    },\n    goToMark: function (cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n            return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n    },\n    moveToOtherHighlightedEnd: function (cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n            var sel = vim.sel;\n            return [\n                clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)),\n                clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))\n            ];\n        }\n        else {\n            return ([vim.sel.head, vim.sel.anchor]);\n        }\n    },\n    jumpToMark: function (cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n            var cursor = best;\n            for (var key in vim.marks) {\n                if (!isLowerCase(key)) {\n                    continue;\n                }\n                var mark = vim.marks[key].find();\n                var isWrongDirection = (motionArgs.forward) ?\n                    cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n                if (isWrongDirection) {\n                    continue;\n                }\n                if (motionArgs.linewise && (mark.line == cursor.line)) {\n                    continue;\n                }\n                var equal = cursorEqual(cursor, best);\n                var between = (motionArgs.forward) ?\n                    cursorIsBetween(cursor, mark, best) :\n                    cursorIsBetween(best, mark, cursor);\n                if (equal || between) {\n                    best = mark;\n                }\n            }\n        }\n        if (motionArgs.linewise) {\n            best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n    },\n    moveByCharacters: function (_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return new Pos(cur.line, ch);\n    },\n    moveByLines: function (cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        switch (vim.lastMotion) {\n            case this.moveByLines:\n            case this.moveByDisplayLines:\n            case this.moveByScroll:\n            case this.moveToColumn:\n            case this.moveToEol:\n                endCh = vim.lastHPos;\n                break;\n            default:\n                vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        if (line < first && cur.line == first) {\n            return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        }\n        else if (line > last && cur.line == last) {\n            return moveToEol(cm, head, motionArgs, vim, true);\n        }\n        var fold = cm.ace.session.getFoldLine(line);\n        if (fold) {\n            if (motionArgs.forward) {\n                if (line > fold.start.row)\n                    line = fold.end.row + 1;\n            }\n            else {\n                line = fold.start.row;\n            }\n        }\n        if (motionArgs.toFirstChar) {\n            endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n            vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(new Pos(line, endCh), 'div').left;\n        return new Pos(line, endCh);\n    },\n    moveByDisplayLines: function (cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n            case this.moveByDisplayLines:\n            case this.moveByScroll:\n            case this.moveByLines:\n            case this.moveToColumn:\n            case this.moveToEol:\n                break;\n            default:\n                vim.lastHSPos = cm.charCoords(cur, 'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res = cm.findPosV(cur, (motionArgs.forward ? repeat : -repeat), 'line', vim.lastHSPos);\n        if (res.hitSide) {\n            if (motionArgs.forward) {\n                var lastCharCoords = cm.charCoords(res, 'div');\n                var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n                var res = cm.coordsChar(goalCoords, 'div');\n            }\n            else {\n                var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), 'div');\n                resCoords.left = vim.lastHSPos;\n                res = cm.coordsChar(resCoords, 'div');\n            }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n    },\n    moveByPage: function (cm, head, motionArgs) {\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n    },\n    moveByParagraph: function (cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n    },\n    moveBySentence: function (cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findSentence(cm, head, motionArgs.repeat, dir);\n    },\n    moveByScroll: function (cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n            repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n            return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n    },\n    moveByWords: function (cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward, !!motionArgs.wordEnd, !!motionArgs.bigWord);\n    },\n    moveTillCharacter: function (cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter, head);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd)\n            return null;\n        curEnd.ch += increment;\n        return curEnd;\n    },\n    moveToCharacter: function (cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter, head) || head;\n    },\n    moveToSymbol: function (cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n    },\n    moveToColumn: function (cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head, 'div').left;\n        return moveToColumn(cm, repeat);\n    },\n    moveToEol: function (cm, head, motionArgs, vim) {\n        return moveToEol(cm, head, motionArgs, vim, false);\n    },\n    moveToFirstNonWhiteSpaceCharacter: function (cm, head) {\n        var cursor = head;\n        return new Pos(cursor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n    },\n    moveToMatchedSymbol: function (cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        for (; ch < lineText.length; ch++) {\n            symbol = lineText.charAt(ch);\n            if (symbol && isMatchableSymbol(symbol)) {\n                var style = cm.getTokenTypeAt(new Pos(line, ch + 1));\n                if (style !== \"string\" && style !== \"comment\") {\n                    break;\n                }\n            }\n        }\n        if (ch < lineText.length) {\n            var re = /[<>]/.test(lineText[ch]) ? /[(){}[\\]<>]/ : /[(){}[\\]]/; //ace_patch?\n            var matched = cm.findMatchingBracket(new Pos(line, ch + 1), { bracketRegex: re });\n            return matched.to;\n        }\n        else {\n            return cursor;\n        }\n    },\n    moveToStartOfLine: function (_cm, head) {\n        return new Pos(head.line, 0);\n    },\n    moveToLineOrEdgeOfDocument: function (cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n            lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return new Pos(lineNum, findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n    },\n    moveToStartOfDisplayLine: function (cm) {\n        cm.execCommand(\"goLineLeft\");\n        return cm.getCursor();\n    },\n    moveToEndOfDisplayLine: function (cm) {\n        cm.execCommand(\"goLineRight\");\n        var head = cm.getCursor();\n        if (head.sticky == \"before\")\n            head.ch--;\n        return head;\n    },\n    textObjectManipulation: function (cm, head, motionArgs, vim) {\n        var mirroredPairs = { '(': ')', ')': '(',\n            '{': '}', '}': '{',\n            '[': ']', ']': '[',\n            '<': '>', '>': '<' };\n        var selfPaired = { '\\'': true, '\"': true, '`': true };\n        var character = motionArgs.selectedCharacter;\n        if (character == 'b') {\n            character = '(';\n        }\n        else if (character == 'B') {\n            character = '{';\n        }\n        var inclusive = !motionArgs.textObjectInner;\n        var tmp, move;\n        if (mirroredPairs[character]) {\n            move = true;\n            tmp = selectCompanionObject(cm, head, character, inclusive);\n            if (!tmp) {\n                var sc = cm.getSearchCursor(new RegExp(\"\\\\\" + character, \"g\"), head);\n                if (sc.find()) {\n                    tmp = selectCompanionObject(cm, sc.from(), character, inclusive);\n                }\n            }\n        }\n        else if (selfPaired[character]) {\n            move = true;\n            tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        }\n        else if (character === 'W' || character === 'w') {\n            var repeat = motionArgs.repeat || 1;\n            while (repeat-- > 0) {\n                var repeated = expandWordUnderCursor(cm, {\n                    inclusive: inclusive,\n                    innerWord: !inclusive,\n                    bigWord: character === 'W',\n                    noSymbol: character === 'W',\n                    multiline: true\n                }, tmp && tmp.end);\n                if (repeated) {\n                    if (!tmp)\n                        tmp = repeated;\n                    tmp.end = repeated.end;\n                }\n            }\n        }\n        else if (character === 'p') {\n            tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n            motionArgs.linewise = true;\n            if (vim.visualMode) {\n                if (!vim.visualLine) {\n                    vim.visualLine = true;\n                }\n            }\n            else {\n                var operatorArgs = vim.inputState.operatorArgs;\n                if (operatorArgs) {\n                    operatorArgs.linewise = true;\n                }\n                tmp.end.line--;\n            }\n        }\n        else if (character === 't') {\n            tmp = expandTagUnderCursor(cm, head, inclusive);\n        }\n        else if (character === 's') {\n            var content = cm.getLine(head.line);\n            if (head.ch > 0 && isEndOfSentenceSymbol(content[head.ch])) {\n                head.ch -= 1;\n            }\n            var end = getSentence(cm, head, motionArgs.repeat, 1, inclusive);\n            var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive);\n            if (isWhiteSpaceString(cm.getLine(start.line)[start.ch])\n                && isWhiteSpaceString(cm.getLine(end.line)[end.ch - 1])) {\n                start = { line: start.line, ch: start.ch + 1 };\n            }\n            tmp = { start: start, end: end };\n        }\n        if (!tmp) {\n            return null;\n        }\n        if (!cm.state.vim.visualMode) {\n            return [tmp.start, tmp.end];\n        }\n        else {\n            return expandSelection(cm, tmp.start, tmp.end, move);\n        }\n    },\n    repeatLastCharacterSearch: function (cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n            cm.moveH(increment, 'char');\n            return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n    }\n};\nfunction defineMotion(name, fn) {\n    motions[name] = fn;\n}\nfunction fillArray(val, times) {\n    var arr = [];\n    for (var i = 0; i < times; i++) {\n        arr.push(val);\n    }\n    return arr;\n}\nvar operators = {\n    change: function (cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        var anchor = ranges[0].anchor, head = ranges[0].head;\n        if (!vim.visualMode) {\n            text = cm.getRange(anchor, head);\n            var lastState = vim.lastEditInputState || {};\n            if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n                var match = (/\\s+$/).exec(text);\n                if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n                    head = offsetCursor(head, 0, -match[0].length);\n                    text = text.slice(0, -match[0].length);\n                }\n            }\n            if (args.linewise) {\n                anchor = new Pos(anchor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(anchor.line)));\n                if (head.line > anchor.line) {\n                    head = new Pos(head.line - 1, Number.MAX_VALUE);\n                }\n            }\n            cm.replaceRange('', anchor, head);\n            finalHead = anchor;\n        }\n        else if (args.fullLine) {\n            head.ch = Number.MAX_VALUE;\n            head.line--;\n            cm.setSelection(anchor, head);\n            text = cm.getSelection();\n            cm.replaceSelection(\"\");\n            finalHead = anchor;\n        }\n        else {\n            text = cm.getSelection();\n            var replacement = fillArray('', ranges.length);\n            cm.replaceSelections(replacement);\n            finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(args.registerName, 'change', text, args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, { head: finalHead }, cm.state.vim);\n    },\n    'delete': function (cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n            var anchor = ranges[0].anchor, head = ranges[0].head;\n            if (args.linewise &&\n                head.line != cm.firstLine() &&\n                anchor.line == cm.lastLine() &&\n                anchor.line == head.line - 1) {\n                if (anchor.line == cm.firstLine()) {\n                    anchor.ch = 0;\n                }\n                else {\n                    anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n                }\n            }\n            text = cm.getRange(anchor, head);\n            cm.replaceRange('', anchor, head);\n            finalHead = anchor;\n            if (args.linewise) {\n                finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n            }\n        }\n        else {\n            text = cm.getSelection();\n            var replacement = fillArray('', ranges.length);\n            cm.replaceSelections(replacement);\n            finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(args.registerName, 'delete', text, args.linewise, vim.visualBlock);\n        return clipCursorToContent(cm, finalHead);\n    },\n    indent: function (cm, args, ranges) {\n        var vim = cm.state.vim;\n        if (cm.indentMore) {\n            var repeat = (vim.visualMode) ? args.repeat : 1;\n            for (var j = 0; j < repeat; j++) {\n                if (args.indentRight)\n                    cm.indentMore();\n                else\n                    cm.indentLess();\n            }\n        }\n        else {\n            var startLine = ranges[0].anchor.line;\n            var endLine = vim.visualBlock ?\n                ranges[ranges.length - 1].anchor.line :\n                ranges[0].head.line;\n            var repeat = (vim.visualMode) ? args.repeat : 1;\n            if (args.linewise) {\n                endLine--;\n            }\n            for (var i = startLine; i <= endLine; i++) {\n                for (var j = 0; j < repeat; j++) {\n                    cm.indentLine(i, args.indentRight);\n                }\n            }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    indentAuto: function (cm, _args, ranges) {\n        cm.execCommand(\"indentAuto\");\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    hardWrap: function (cm, operatorArgs, ranges, oldAnchor, newHead) {\n        if (!cm.hardWrap)\n            return;\n        var from = ranges[0].anchor.line;\n        var to = ranges[0].head.line;\n        if (operatorArgs.linewise)\n            to--;\n        var endRow = cm.hardWrap({ from: from, to: to });\n        if (endRow > from && operatorArgs.linewise)\n            endRow--;\n        return operatorArgs.keepCursor ? oldAnchor : new Pos(endRow, 0);\n    },\n    changeCase: function (cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n            var toSwap = selections[j];\n            var text = '';\n            if (toLower === true) {\n                text = toSwap.toLowerCase();\n            }\n            else if (toLower === false) {\n                text = toSwap.toUpperCase();\n            }\n            else {\n                for (var i = 0; i < toSwap.length; i++) {\n                    var character = toSwap.charAt(i);\n                    text += isUpperCase(character) ? character.toLowerCase() :\n                        character.toUpperCase();\n                }\n            }\n            swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor) {\n            return newHead;\n        }\n        else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n            return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        }\n        else if (args.linewise) {\n            return oldAnchor;\n        }\n        else {\n            return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n    },\n    yank: function (cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n            ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n            : oldAnchor;\n        vimGlobalState.registerController.pushText(args.registerName, 'yank', text, args.linewise, vim.visualBlock);\n        return endPos;\n    }\n};\nfunction defineOperator(name, fn) {\n    operators[name] = fn;\n}\nvar actions = {\n    jumpListWalk: function (cm, actionArgs, vim) {\n        if (vim.visualMode) {\n            return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n        cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\n    },\n    scroll: function (cm, actionArgs, vim) {\n        if (vim.visualMode) {\n            return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n            if (newPos > cursorCoords.top) {\n                cursor.line += (newPos - cursorCoords.top) / lineHeight;\n                cursor.line = Math.ceil(cursor.line);\n                cm.setCursor(cursor);\n                cursorCoords = cm.charCoords(cursor, 'local');\n                cm.scrollTo(null, cursorCoords.top);\n            }\n            else {\n                cm.scrollTo(null, newPos);\n            }\n        }\n        else {\n            var newBottom = newPos + cm.getScrollInfo().clientHeight;\n            if (newBottom < cursorCoords.bottom) {\n                cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n                cursor.line = Math.floor(cursor.line);\n                cm.setCursor(cursor);\n                cursorCoords = cm.charCoords(cursor, 'local');\n                cm.scrollTo(null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n            }\n            else {\n                cm.scrollTo(null, newPos);\n            }\n        }\n    },\n    scrollToCursor: function (cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(new Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        switch (actionArgs.position) {\n            case 'center':\n                y = charCoords.bottom - height / 2;\n                break;\n            case 'bottom':\n                var lineLastCharPos = new Pos(lineNum, cm.getLine(lineNum).length - 1);\n                var lineLastCharCoords = cm.charCoords(lineLastCharPos, 'local');\n                var lineHeight = lineLastCharCoords.bottom - y;\n                y = y - height + lineHeight;\n                break;\n        }\n        cm.scrollTo(null, y);\n    },\n    replayMacro: function (cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n            registerName = macroModeState.latestRegister;\n        }\n        else {\n            macroModeState.latestRegister = registerName;\n        }\n        while (repeat--) {\n            executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n    },\n    enterMacroRecordMode: function (cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n            macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n    },\n    toggleOverwrite: function (cm) {\n        if (!cm.state.overwrite) {\n            cm.toggleOverwrite(true);\n            cm.setOption('keyMap', 'vim-replace');\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"replace\" });\n        }\n        else {\n            cm.toggleOverwrite(false);\n            cm.setOption('keyMap', 'vim-insert');\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"insert\" });\n        }\n    },\n    enterInsertMode: function (cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) {\n            return;\n        }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n            head = new Pos(head.line, lineLength(cm, head.line));\n        }\n        else if (insertAt == 'bol') {\n            head = new Pos(head.line, 0);\n        }\n        else if (insertAt == 'charAfter') {\n            var newPosition = updateSelectionForSurrogateCharacters(cm, head, offsetCursor(head, 0, 1));\n            head = newPosition.end;\n        }\n        else if (insertAt == 'firstNonBlank') {\n            var newPosition = updateSelectionForSurrogateCharacters(cm, head, motions.moveToFirstNonWhiteSpaceCharacter(cm, head));\n            head = newPosition.end;\n        }\n        else if (insertAt == 'startOfSelectedArea') {\n            if (!vim.visualMode)\n                return;\n            if (!vim.visualBlock) {\n                if (sel.head.line < sel.anchor.line) {\n                    head = sel.head;\n                }\n                else {\n                    head = new Pos(sel.anchor.line, 0);\n                }\n            }\n            else {\n                head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.min(sel.head.ch, sel.anchor.ch));\n                height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n            }\n        }\n        else if (insertAt == 'endOfSelectedArea') {\n            if (!vim.visualMode)\n                return;\n            if (!vim.visualBlock) {\n                if (sel.head.line >= sel.anchor.line) {\n                    head = offsetCursor(sel.head, 0, 1);\n                }\n                else {\n                    head = new Pos(sel.anchor.line, 0);\n                }\n            }\n            else {\n                head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.max(sel.head.ch, sel.anchor.ch) + 1);\n                height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n            }\n        }\n        else if (insertAt == 'inplace') {\n            if (vim.visualMode) {\n                return;\n            }\n        }\n        else if (insertAt == 'lastEdit') {\n            head = getLastEditPos(cm) || head;\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n            cm.toggleOverwrite(true);\n            cm.setOption('keyMap', 'vim-replace');\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"replace\" });\n        }\n        else {\n            cm.toggleOverwrite(false);\n            cm.setOption('keyMap', 'vim-insert');\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"insert\" });\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n            cm.on('change', onChange);\n            if (vim.insertEnd)\n                vim.insertEnd.clear();\n            vim.insertEnd = cm.setBookmark(head, { insertLeft: true });\n            CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n            exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n    },\n    toggleVisualMode: function (cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        if (!vim.visualMode) {\n            vim.visualMode = true;\n            vim.visualLine = !!actionArgs.linewise;\n            vim.visualBlock = !!actionArgs.blockwise;\n            head = clipCursorToContent(cm, new Pos(anchor.line, anchor.ch + repeat - 1));\n            var newPosition = updateSelectionForSurrogateCharacters(cm, anchor, head);\n            vim.sel = {\n                anchor: newPosition.start,\n                head: newPosition.end\n            };\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\" });\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<', cursorMin(anchor, head));\n            updateMark(cm, vim, '>', cursorMax(anchor, head));\n        }\n        else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n            vim.visualLine = !!actionArgs.linewise;\n            vim.visualBlock = !!actionArgs.blockwise;\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\" });\n            updateCmSelection(cm);\n        }\n        else {\n            exitVisualMode(cm);\n        }\n    },\n    reselectLastSelection: function (cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n            updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n            var anchor = lastSelection.anchorMark.find();\n            var head = lastSelection.headMark.find();\n            if (!anchor || !head) {\n                return;\n            }\n            vim.sel = {\n                anchor: anchor,\n                head: head\n            };\n            vim.visualMode = true;\n            vim.visualLine = lastSelection.visualLine;\n            vim.visualBlock = lastSelection.visualBlock;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<', cursorMin(anchor, head));\n            updateMark(cm, vim, '>', cursorMax(anchor, head));\n            CodeMirror.signal(cm, 'vim-mode-change', {\n                mode: 'visual',\n                subMode: vim.visualLine ? 'linewise' :\n                    vim.visualBlock ? 'blockwise' : ''\n            });\n        }\n    },\n    joinLines: function (cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n            curStart = cm.getCursor('anchor');\n            curEnd = cm.getCursor('head');\n            if (cursorIsBefore(curEnd, curStart)) {\n                var tmp = curEnd;\n                curEnd = curStart;\n                curStart = tmp;\n            }\n            curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        }\n        else {\n            var repeat = Math.max(actionArgs.repeat, 2);\n            curStart = cm.getCursor();\n            curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1, Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n            finalCh = lineLength(cm, curStart.line);\n            var text = '';\n            var nextStartCh = 0;\n            if (!actionArgs.keepSpaces) {\n                var nextLine = cm.getLine(curStart.line + 1);\n                nextStartCh = nextLine.search(/\\S/);\n                if (nextStartCh == -1) {\n                    nextStartCh = nextLine.length;\n                }\n                else {\n                    text = \" \";\n                }\n            }\n            cm.replaceRange(text, new Pos(curStart.line, finalCh), new Pos(curStart.line + 1, nextStartCh));\n        }\n        var curFinalPos = clipCursorToContent(cm, new Pos(curStart.line, finalCh));\n        if (vim.visualMode) {\n            exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n    },\n    newLineAndEnterInsertMode: function (cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n            cm.replaceRange('\\n', new Pos(cm.firstLine(), 0));\n            cm.setCursor(cm.firstLine(), 0);\n        }\n        else {\n            insertAt.line = (actionArgs.after) ? insertAt.line :\n                insertAt.line - 1;\n            insertAt.ch = lineLength(cm, insertAt.line);\n            cm.setCursor(insertAt);\n            var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n                CodeMirror.commands.newlineAndIndent;\n            newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n    },\n    paste: function (cm, actionArgs, vim) {\n        var _this = this;\n        var register = vimGlobalState.registerController.getRegister(actionArgs.registerName);\n        var fallback = function () {\n            var text = register.toString();\n            _this.continuePaste(cm, actionArgs, vim, text, register);\n        };\n        if (actionArgs.registerName === '+' &&\n            typeof navigator !== 'undefined' &&\n            typeof navigator.clipboard !== 'undefined' &&\n            typeof navigator.clipboard.readText === 'function') {\n            navigator.clipboard.readText().then(function (value) {\n                _this.continuePaste(cm, actionArgs, vim, value, register);\n            }, function () { fallback(); });\n        }\n        else {\n            fallback();\n        }\n    },\n    continuePaste: function (cm, actionArgs, vim, text, register) {\n        var cur = copyCursor(cm.getCursor());\n        if (!text) {\n            return;\n        }\n        if (actionArgs.matchIndent) {\n            var tabSize = cm.getOption(\"tabSize\");\n            var whitespaceLength = function (str) {\n                var tabs = (str.split(\"\\t\").length - 1);\n                var spaces = (str.split(\" \").length - 1);\n                return tabs * tabSize + spaces * 1;\n            };\n            var currentLine = cm.getLine(cm.getCursor().line);\n            var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n            var chompedText = text.replace(/\\n$/, '');\n            var wasChomped = text !== chompedText;\n            var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n            var text = chompedText.replace(/^\\s*/gm, function (wspace) {\n                var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n                if (newIndent < 0) {\n                    return \"\";\n                }\n                else if (cm.getOption(\"indentWithTabs\")) {\n                    var quotient = Math.floor(newIndent / tabSize);\n                    return Array(quotient + 1).join('\\t');\n                }\n                else {\n                    return Array(newIndent + 1).join(' ');\n                }\n            });\n            text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n            var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (blockwise) {\n            text = text.split('\\n');\n            if (linewise) {\n                text.pop();\n            }\n            for (var i = 0; i < text.length; i++) {\n                text[i] = (text[i] == '') ? ' ' : text[i];\n            }\n            cur.ch += actionArgs.after ? 1 : 0;\n            cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n        }\n        else if (linewise) {\n            if (vim.visualMode) {\n                text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n            }\n            else if (actionArgs.after) {\n                text = '\\n' + text.slice(0, text.length - 1);\n                cur.ch = lineLength(cm, cur.line);\n            }\n            else {\n                cur.ch = 0;\n            }\n        }\n        else {\n            cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        if (vim.visualMode) {\n            vim.lastPastedText = text;\n            var lastSelectionCurEnd;\n            var selectedArea = getSelectedAreaRange(cm, vim);\n            var selectionStart = selectedArea[0];\n            var selectionEnd = selectedArea[1];\n            var selectedText = cm.getSelection();\n            var selections = cm.listSelections();\n            var emptyStrings = new Array(selections.length).join('1').split('1');\n            if (vim.lastSelection) {\n                lastSelectionCurEnd = vim.lastSelection.headMark.find();\n            }\n            vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n            if (blockwise) {\n                cm.replaceSelections(emptyStrings);\n                selectionEnd = new Pos(selectionStart.line + text.length - 1, selectionStart.ch);\n                cm.setCursor(selectionStart);\n                selectBlock(cm, selectionEnd);\n                cm.replaceSelections(text);\n                curPosFinal = selectionStart;\n            }\n            else if (vim.visualBlock) {\n                cm.replaceSelections(emptyStrings);\n                cm.setCursor(selectionStart);\n                cm.replaceRange(text, selectionStart, selectionStart);\n                curPosFinal = selectionStart;\n            }\n            else {\n                cm.replaceRange(text, selectionStart, selectionEnd);\n                curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n            }\n            if (lastSelectionCurEnd) {\n                vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n            }\n            if (linewise) {\n                curPosFinal.ch = 0;\n            }\n        }\n        else {\n            if (blockwise) {\n                cm.setCursor(cur);\n                for (var i = 0; i < text.length; i++) {\n                    var line = cur.line + i;\n                    if (line > cm.lastLine()) {\n                        cm.replaceRange('\\n', new Pos(line, 0));\n                    }\n                    var lastCh = lineLength(cm, line);\n                    if (lastCh < cur.ch) {\n                        extendLineToColumn(cm, line, cur.ch);\n                    }\n                }\n                cm.setCursor(cur);\n                selectBlock(cm, new Pos(cur.line + text.length - 1, cur.ch));\n                cm.replaceSelections(text);\n                curPosFinal = cur;\n            }\n            else {\n                cm.replaceRange(text, cur);\n                if (linewise) {\n                    var line = actionArgs.after ? cur.line + 1 : cur.line;\n                    curPosFinal = new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n                }\n                else {\n                    curPosFinal = copyCursor(cur);\n                    if (!/\\n/.test(text)) {\n                        curPosFinal.ch += text.length - (actionArgs.after ? 1 : 0);\n                    }\n                }\n            }\n        }\n        if (vim.visualMode) {\n            exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n    },\n    undo: function (cm, actionArgs) {\n        cm.operation(function () {\n            repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n            cm.setCursor(clipCursorToContent(cm, cm.getCursor('start')));\n        });\n    },\n    redo: function (cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n    },\n    setRegister: function (_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n    },\n    insertRegister: function (cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var register = vimGlobalState.registerController.getRegister(registerName);\n        var text = register && register.toString();\n        if (text) {\n            cm.replaceSelection(text);\n        }\n    },\n    oneNormalCommand: function (cm, actionArgs, vim) {\n        exitInsertMode(cm, true);\n        vim.insertModeReturn = true;\n        CodeMirror.on(cm, 'vim-command-done', function handler() {\n            if (vim.visualMode)\n                return;\n            if (vim.insertModeReturn) {\n                vim.insertModeReturn = false;\n                if (!vim.insertMode) {\n                    actions.enterInsertMode(cm, {}, vim);\n                }\n            }\n            CodeMirror.off(cm, 'vim-command-done', handler);\n        });\n    },\n    setMark: function (cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n    },\n    replace: function (cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n            curStart = cm.getCursor('start');\n            curEnd = cm.getCursor('end');\n        }\n        else {\n            var line = cm.getLine(curStart.line);\n            replaceTo = curStart.ch + actionArgs.repeat;\n            if (replaceTo > line.length) {\n                replaceTo = line.length;\n            }\n            curEnd = new Pos(curStart.line, replaceTo);\n        }\n        var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n        curStart = newPositions.start;\n        curEnd = newPositions.end;\n        if (replaceWith == '\\n') {\n            if (!vim.visualMode)\n                cm.replaceRange('', curStart, curEnd);\n            (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        }\n        else {\n            var replaceWithStr = cm.getRange(curStart, curEnd);\n            replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n            replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n            if (vim.visualBlock) {\n                var spaces = new Array(cm.getOption(\"tabSize\") + 1).join(' ');\n                replaceWithStr = cm.getSelection();\n                replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n                replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n                cm.replaceSelections(replaceWithStr);\n            }\n            else {\n                cm.replaceRange(replaceWithStr, curStart, curEnd);\n            }\n            if (vim.visualMode) {\n                curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                    selections[0].anchor : selections[0].head;\n                cm.setCursor(curStart);\n                exitVisualMode(cm, false);\n            }\n            else {\n                cm.setCursor(offsetCursor(curEnd, 0, -1));\n            }\n        }\n    },\n    incrementNumberToken: function (cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        while ((match = re.exec(lineStr)) !== null) {\n            start = match.index;\n            end = start + match[0].length;\n            if (cur.ch < end)\n                break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))\n            return;\n        if (match) {\n            var baseStr = match[2] || match[4];\n            var digits = match[3] || match[5];\n            var increment = actionArgs.increase ? 1 : -1;\n            var base = { '0b': 2, '0': 8, '': 10, '0x': 16 }[baseStr.toLowerCase()];\n            var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);\n            numberStr = number.toString(base);\n            var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n            if (numberStr.charAt(0) === '-') {\n                numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n            }\n            else {\n                numberStr = baseStr + zeroPadding + numberStr;\n            }\n            var from = new Pos(cur.line, start);\n            var to = new Pos(cur.line, end);\n            cm.replaceRange(numberStr, from, to);\n        }\n        else {\n            return;\n        }\n        cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));\n    },\n    repeatLastEdit: function (cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) {\n            return;\n        }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n            vim.lastEditInputState.repeatOverride = repeat;\n        }\n        else {\n            repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n    },\n    indent: function (cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n    },\n    exitInsertMode: exitInsertMode\n};\nfunction defineAction(name, fn) {\n    actions[name] = fn;\n}\nfunction clipCursorToContent(cm, cur, oldCur) {\n    var vim = cm.state.vim;\n    var includeLineBreak = vim.insertMode || vim.visualMode;\n    var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine());\n    var text = cm.getLine(line);\n    var maxCh = text.length - 1 + Number(!!includeLineBreak);\n    var ch = Math.min(Math.max(0, cur.ch), maxCh);\n    var charCode = text.charCodeAt(ch);\n    if (0xDC00 <= charCode && charCode <= 0xDFFF) {\n        var direction = 1;\n        if (oldCur && oldCur.line == line && oldCur.ch > ch) {\n            direction = -1;\n        }\n        ch += direction;\n        if (ch > maxCh)\n            ch -= 2;\n    }\n    return new Pos(line, ch);\n}\nfunction copyArgs(args) {\n    var ret = {};\n    for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n            ret[prop] = args[prop];\n        }\n    }\n    return ret;\n}\nfunction offsetCursor(cur, offsetLine, offsetCh) {\n    if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n    }\n    return new Pos(cur.line + offsetLine, cur.ch + offsetCh);\n}\nfunction commandMatches(keys, keyMap, context, inputState) {\n    if (inputState.operator)\n        context = \"operatorPending\";\n    var match, partial = [], full = [];\n    var startIndex = noremap ? keyMap.length - defaultKeymapLength : 0;\n    for (var i = startIndex; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            (command.context && command.context != context) ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) {\n            continue;\n        }\n        if (match == 'partial') {\n            partial.push(command);\n        }\n        if (match == 'full') {\n            full.push(command);\n        }\n    }\n    return {\n        partial: partial.length && partial,\n        full: full.length && full\n    };\n}\nfunction commandMatch(pressed, mapped) {\n    var isLastCharacter = mapped.slice(-11) == '<character>';\n    var isLastRegister = mapped.slice(-10) == '<register>';\n    if (isLastCharacter || isLastRegister) {\n        var prefixLen = mapped.length - (isLastCharacter ? 11 : 10);\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n            mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n    }\n    else {\n        return pressed == mapped ? 'full' :\n            mapped.indexOf(pressed) == 0 ? 'partial' : false;\n    }\n}\nfunction lastChar(keys) {\n    var match = /^.*(<[^>]+>)$/.exec(keys);\n    var selectedCharacter = match ? match[1] : keys.slice(-1);\n    if (selectedCharacter.length > 1) {\n        switch (selectedCharacter) {\n            case '<CR>':\n                selectedCharacter = '\\n';\n                break;\n            case '<Space>':\n                selectedCharacter = ' ';\n                break;\n            default:\n                selectedCharacter = '';\n                break;\n        }\n    }\n    return selectedCharacter;\n}\nfunction repeatFn(cm, fn, repeat) {\n    return function () {\n        for (var i = 0; i < repeat; i++) {\n            fn(cm);\n        }\n    };\n}\nfunction copyCursor(cur) {\n    return new Pos(cur.line, cur.ch);\n}\nfunction cursorEqual(cur1, cur2) {\n    return cur1.ch == cur2.ch && cur1.line == cur2.line;\n}\nfunction cursorIsBefore(cur1, cur2) {\n    if (cur1.line < cur2.line) {\n        return true;\n    }\n    if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n    }\n    return false;\n}\nfunction cursorMin(cur1, cur2) {\n    if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n    return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n}\nfunction cursorMax(cur1, cur2) {\n    if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n    return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n}\nfunction cursorIsBetween(cur1, cur2, cur3) {\n    var cur1before2 = cursorIsBefore(cur1, cur2);\n    var cur2before3 = cursorIsBefore(cur2, cur3);\n    return cur1before2 && cur2before3;\n}\nfunction lineLength(cm, lineNum) {\n    return cm.getLine(lineNum).length;\n}\nfunction trim(s) {\n    if (s.trim) {\n        return s.trim();\n    }\n    return s.replace(/^\\s+|\\s+$/g, '');\n}\nfunction escapeRegex(s) {\n    return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n}\nfunction extendLineToColumn(cm, lineNum, column) {\n    var endCh = lineLength(cm, lineNum);\n    var spaces = new Array(column - endCh + 1).join(' ');\n    cm.setCursor(new Pos(lineNum, endCh));\n    cm.replaceRange(spaces, cm.getCursor());\n}\nfunction selectBlock(cm, selectionEnd) {\n    var selections = [], ranges = cm.listSelections();\n    var head = copyCursor(cm.clipPos(selectionEnd));\n    var isClipped = !cursorEqual(selectionEnd, head);\n    var curHead = cm.getCursor('head');\n    var primIndex = getIndex(ranges, curHead);\n    var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n    var max = ranges.length - 1;\n    var index = max - primIndex > primIndex ? max : 0;\n    var base = ranges[index].anchor;\n    var firstLine = Math.min(base.line, head.line);\n    var lastLine = Math.max(base.line, head.line);\n    var baseCh = base.ch, headCh = head.ch;\n    var dir = ranges[index].head.ch - baseCh;\n    var newDir = headCh - baseCh;\n    if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) {\n            headCh--;\n        }\n    }\n    else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) {\n            headCh++;\n        }\n    }\n    else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n    }\n    for (var line = firstLine; line <= lastLine; line++) {\n        var range = { anchor: new Pos(line, baseCh), head: new Pos(line, headCh) };\n        selections.push(range);\n    }\n    cm.setSelections(selections);\n    selectionEnd.ch = headCh;\n    base.ch = baseCh;\n    return base;\n}\nfunction selectForInsert(cm, head, height) {\n    var sel = [];\n    for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({ anchor: lineHead, head: lineHead });\n    }\n    cm.setSelections(sel, 0);\n}\nfunction getIndex(ranges, cursor, end) {\n    for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction getSelectedAreaRange(cm, vim) {\n    var lastSelection = vim.lastSelection;\n    var getCurrentSelectedAreaRange = function () {\n        var selections = cm.listSelections();\n        var start = selections[0];\n        var end = selections[selections.length - 1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n    };\n    var getLastSelectedAreaRange = function () {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n            var width = block.width;\n            var height = block.height;\n            selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);\n            var selections = [];\n            for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n                var anchor = new Pos(i, selectionStart.ch);\n                var head = new Pos(i, selectionEnd.ch);\n                var range = { anchor: anchor, head: head };\n                selections.push(range);\n            }\n            cm.setSelections(selections);\n        }\n        else {\n            var start = lastSelection.anchorMark.find();\n            var end = lastSelection.headMark.find();\n            var line = end.line - start.line;\n            var ch = end.ch - start.ch;\n            selectionEnd = { line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch };\n            if (lastSelection.visualLine) {\n                selectionStart = new Pos(selectionStart.line, 0);\n                selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n            }\n            cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n    };\n    if (!vim.visualMode) {\n        return getLastSelectedAreaRange();\n    }\n    else {\n        return getCurrentSelectedAreaRange();\n    }\n}\nfunction updateLastSelection(cm, vim) {\n    var anchor = vim.sel.anchor;\n    var head = vim.sel.head;\n    if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n    }\n    vim.lastSelection = { 'anchorMark': cm.setBookmark(anchor),\n        'headMark': cm.setBookmark(head),\n        'anchor': copyCursor(anchor),\n        'head': copyCursor(head),\n        'visualMode': vim.visualMode,\n        'visualLine': vim.visualLine,\n        'visualBlock': vim.visualBlock };\n}\nfunction expandSelection(cm, start, end, move) {\n    var sel = cm.state.vim.sel;\n    var head = move ? start : sel.head;\n    var anchor = move ? start : sel.anchor;\n    var tmp;\n    if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n    }\n    if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n    }\n    else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n            head = new Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n    }\n    return [anchor, head];\n}\nfunction updateCmSelection(cm, sel, mode) {\n    var vim = cm.state.vim;\n    sel = sel || vim.sel;\n    var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n    var cmSel = makeCmSelection(cm, sel, mode);\n    cm.setSelections(cmSel.ranges, cmSel.primary);\n}\nfunction makeCmSelection(cm, sel, mode, exclusive) {\n    var head = copyCursor(sel.head);\n    var anchor = copyCursor(sel.anchor);\n    if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n            ranges: [{ anchor: anchor, head: head }],\n            primary: 0\n        };\n    }\n    else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n            anchor.ch = 0;\n            var lastLine = cm.lastLine();\n            if (head.line > lastLine) {\n                head.line = lastLine;\n            }\n            head.ch = lineLength(cm, head.line);\n        }\n        else {\n            head.ch = 0;\n            anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n            ranges: [{ anchor: anchor, head: head }],\n            primary: 0\n        };\n    }\n    else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line), fromCh = anchor.ch, bottom = Math.max(anchor.line, head.line), toCh = head.ch;\n        if (fromCh < toCh) {\n            toCh += 1;\n        }\n        else {\n            fromCh += 1;\n        }\n        ;\n        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n            ranges.push({\n                anchor: new Pos(top + i, fromCh),\n                head: new Pos(top + i, toCh)\n            });\n        }\n        return {\n            ranges: ranges,\n            primary: primary\n        };\n    }\n}\nfunction getHead(cm) {\n    var cur = cm.getCursor('head');\n    if (cm.getSelection().length == 1) {\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n    }\n    return cur;\n}\nfunction exitVisualMode(cm, moveHead) {\n    var vim = cm.state.vim;\n    if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n    }\n    updateLastSelection(cm, vim);\n    vim.visualMode = false;\n    vim.visualLine = false;\n    vim.visualBlock = false;\n    if (!vim.insertMode)\n        CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"normal\" });\n}\nfunction clipToLine(cm, curStart, curEnd) {\n    var selection = cm.getRange(curStart, curEnd);\n    if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        lines.pop();\n        var line;\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n            curEnd.line--;\n            curEnd.ch = 0;\n        }\n        if (line) {\n            curEnd.line--;\n            curEnd.ch = lineLength(cm, curEnd.line);\n        }\n        else {\n            curEnd.ch = 0;\n        }\n    }\n}\nfunction expandSelectionToLine(_cm, curStart, curEnd) {\n    curStart.ch = 0;\n    curEnd.ch = 0;\n    curEnd.line++;\n}\nfunction findFirstNonWhiteSpaceCharacter(text) {\n    if (!text) {\n        return 0;\n    }\n    var firstNonWS = text.search(/\\S/);\n    return firstNonWS == -1 ? text.length : firstNonWS;\n}\nfunction expandWordUnderCursor(cm, _a, cursor) {\n    var inclusive = _a.inclusive, innerWord = _a.innerWord, bigWord = _a.bigWord, noSymbol = _a.noSymbol, multiline = _a.multiline;\n    var cur = cursor || getHead(cm);\n    var line = cm.getLine(cur.line);\n    var endLine = line;\n    var startLineNumber = cur.line;\n    var endLineNumber = startLineNumber;\n    var idx = cur.ch;\n    var wordOnNextLine;\n    var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0];\n    if (innerWord && /\\s/.test(line.charAt(idx))) {\n        test = function (ch) { return /\\s/.test(ch); };\n    }\n    else {\n        while (!test(line.charAt(idx))) {\n            idx++;\n            if (idx >= line.length) {\n                if (!multiline)\n                    return null;\n                idx--;\n                wordOnNextLine = findWord(cm, cur, true, bigWord, true);\n                break;\n            }\n        }\n        if (bigWord) {\n            test = bigWordCharTest[0];\n        }\n        else {\n            test = wordCharTest[0];\n            if (!test(line.charAt(idx))) {\n                test = wordCharTest[1];\n            }\n        }\n    }\n    var end = idx, start = idx;\n    while (test(line.charAt(start)) && start >= 0) {\n        start--;\n    }\n    start++;\n    if (wordOnNextLine) {\n        end = wordOnNextLine.to;\n        endLineNumber = wordOnNextLine.line;\n        endLine = cm.getLine(endLineNumber);\n        if (!endLine && end == 0)\n            end++;\n    }\n    else {\n        while (test(line.charAt(end)) && end < line.length) {\n            end++;\n        }\n    }\n    if (inclusive) {\n        var wordEnd = end;\n        var startsWithSpace = cur.ch <= start && /\\s/.test(line.charAt(cur.ch));\n        if (!startsWithSpace) {\n            while (/\\s/.test(endLine.charAt(end)) && end < endLine.length) {\n                end++;\n            }\n        }\n        if (wordEnd == end || startsWithSpace) {\n            var wordStart = start;\n            while (/\\s/.test(line.charAt(start - 1)) && start > 0) {\n                start--;\n            }\n            if (!start && !startsWithSpace) {\n                start = wordStart;\n            }\n        }\n    }\n    return { start: new Pos(startLineNumber, start), end: new Pos(endLineNumber, end) };\n}\nfunction expandTagUnderCursor(cm, head, inclusive) {\n    var cur = head;\n    if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {\n        return { start: cur, end: cur };\n    }\n    var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);\n    if (!tags || !tags.open || !tags.close) {\n        return { start: cur, end: cur };\n    }\n    if (inclusive) {\n        return { start: tags.open.from, end: tags.close.to };\n    }\n    return { start: tags.open.to, end: tags.close.from };\n}\nfunction recordJumpPosition(cm, oldCur, newCur) {\n    if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n    }\n}\nfunction recordLastCharacterSearch(increment, args) {\n    vimGlobalState.lastCharacterSearch.increment = increment;\n    vimGlobalState.lastCharacterSearch.forward = args.forward;\n    vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n}\nvar symbolToMode = {\n    '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n    '[': 'section', ']': 'section',\n    '*': 'comment', '/': 'comment',\n    'm': 'method', 'M': 'method',\n    '#': 'preprocess'\n};\nvar findSymbolModes = {\n    bracket: {\n        isComplete: function (state) {\n            if (state.nextCh === state.symb) {\n                state.depth++;\n                if (state.depth >= 1)\n                    return true;\n            }\n            else if (state.nextCh === state.reverseSymb) {\n                state.depth--;\n            }\n            return false;\n        }\n    },\n    section: {\n        init: function (state) {\n            state.curMoveThrough = true;\n            state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function (state) {\n            return state.index === 0 && state.nextCh === state.symb;\n        }\n    },\n    comment: {\n        isComplete: function (state) {\n            var found = state.lastCh === '*' && state.nextCh === '/';\n            state.lastCh = state.nextCh;\n            return found;\n        }\n    },\n    method: {\n        init: function (state) {\n            state.symb = (state.symb === 'm' ? '{' : '}');\n            state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function (state) {\n            if (state.nextCh === state.symb)\n                return true;\n            return false;\n        }\n    },\n    preprocess: {\n        init: function (state) {\n            state.index = 0;\n        },\n        isComplete: function (state) {\n            if (state.nextCh === '#') {\n                var token = state.lineText.match(/^#(\\w+)/)[1];\n                if (token === 'endif') {\n                    if (state.forward && state.depth === 0) {\n                        return true;\n                    }\n                    state.depth++;\n                }\n                else if (token === 'if') {\n                    if (!state.forward && state.depth === 0) {\n                        return true;\n                    }\n                    state.depth--;\n                }\n                if (token === 'else' && state.depth === 0)\n                    return true;\n            }\n            return false;\n        }\n    }\n};\nfunction findSymbol(cm, repeat, forward, symb) {\n    var cur = copyCursor(cm.getCursor());\n    var increment = forward ? 1 : -1;\n    var endLine = forward ? cm.lineCount() : -1;\n    var curCh = cur.ch;\n    var line = cur.line;\n    var lineText = cm.getLine(line);\n    var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ? { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n    };\n    var mode = symbolToMode[symb];\n    if (!mode)\n        return cur;\n    var init = findSymbolModes[mode].init;\n    var isComplete = findSymbolModes[mode].isComplete;\n    if (init) {\n        init(state);\n    }\n    while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n            line += increment;\n            state.lineText = cm.getLine(line) || '';\n            if (increment > 0) {\n                state.index = 0;\n            }\n            else {\n                var lineLen = state.lineText.length;\n                state.index = (lineLen > 0) ? (lineLen - 1) : 0;\n            }\n            state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n            cur.line = line;\n            cur.ch = state.index;\n            repeat--;\n        }\n    }\n    if (state.nextCh || state.curMoveThrough) {\n        return new Pos(line, state.index);\n    }\n    return cur;\n}\nfunction findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n    var lineNum = cur.line;\n    var pos = cur.ch;\n    var line = cm.getLine(lineNum);\n    var dir = forward ? 1 : -1;\n    var charTests = bigWord ? bigWordCharTest : wordCharTest;\n    if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n            return null;\n        }\n        pos = (forward) ? 0 : line.length;\n    }\n    while (true) {\n        if (emptyLineIsWord && line == '') {\n            return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        while (pos != stop) {\n            var foundWord = false;\n            for (var i = 0; i < charTests.length && !foundWord; ++i) {\n                if (charTests[i](line.charAt(pos))) {\n                    wordStart = pos;\n                    while (pos != stop && charTests[i](line.charAt(pos))) {\n                        pos += dir;\n                    }\n                    wordEnd = pos;\n                    foundWord = wordStart != wordEnd;\n                    if (wordStart == cur.ch && lineNum == cur.line &&\n                        wordEnd == wordStart + dir) {\n                        continue;\n                    }\n                    else {\n                        return {\n                            from: Math.min(wordStart, wordEnd + 1),\n                            to: Math.max(wordStart, wordEnd),\n                            line: lineNum\n                        };\n                    }\n                }\n            }\n            if (!foundWord) {\n                pos += dir;\n            }\n        }\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n            return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n    }\n}\nfunction moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n    var curStart = copyCursor(cur);\n    var words = [];\n    if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n    }\n    var emptyLineIsWord = !(forward && wordEnd);\n    for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n            var eodCh = lineLength(cm, cm.lastLine());\n            words.push(forward\n                ? { line: cm.lastLine(), from: eodCh, to: eodCh }\n                : { line: 0, from: 0, to: 0 });\n            break;\n        }\n        words.push(word);\n        cur = new Pos(word.line, forward ? (word.to - 1) : word.from);\n    }\n    var shortCircuit = words.length != repeat;\n    var firstWord = words[0];\n    var lastWord = words.pop();\n    if (forward && !wordEnd) {\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n            lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.from);\n    }\n    else if (forward && wordEnd) {\n        return new Pos(lastWord.line, lastWord.to - 1);\n    }\n    else if (!forward && wordEnd) {\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n            lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.to);\n    }\n    else {\n        return new Pos(lastWord.line, lastWord.from);\n    }\n}\nfunction moveToEol(cm, head, motionArgs, vim, keepHPos) {\n    var cur = head;\n    var retval = new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    var end = cm.clipPos(retval);\n    end.ch--;\n    if (!keepHPos) {\n        vim.lastHPos = Infinity;\n        vim.lastHSPos = cm.charCoords(end, 'div').left;\n    }\n    return retval;\n}\nfunction moveToCharacter(cm, repeat, forward, character, head) {\n    var cur = head || cm.getCursor();\n    var start = cur.ch;\n    var idx;\n    for (var i = 0; i < repeat; i++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n            return null;\n        }\n        start = idx;\n    }\n    return new Pos(cm.getCursor().line, idx);\n}\nfunction moveToColumn(cm, repeat) {\n    var line = cm.getCursor().line;\n    return clipCursorToContent(cm, new Pos(line, repeat - 1));\n}\nfunction updateMark(cm, vim, markName, pos) {\n    if (!inArray(markName, validMarks) && !latinCharRegex.test(markName)) {\n        return;\n    }\n    if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n    }\n    vim.marks[markName] = cm.setBookmark(pos);\n}\nfunction charIdxInLine(start, line, character, forward, includeChar) {\n    var idx;\n    if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n            idx -= 1;\n        }\n    }\n    else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n            idx += 1;\n        }\n    }\n    return idx;\n}\nfunction findParagraph(cm, head, repeat, dir, inclusive) {\n    var line = head.line;\n    var min = cm.firstLine();\n    var max = cm.lastLine();\n    var start, end, i = line;\n    function isEmpty(i) { return !/\\S/.test(cm.getLine(i)); } // ace_patch\n    function isBoundary(i, dir, any) {\n        if (any) {\n            return isEmpty(i) != isEmpty(i + dir);\n        }\n        return !isEmpty(i) && isEmpty(i + dir);\n    }\n    function skipFold(i) {\n        dir = dir > 0 ? 1 : -1;\n        var foldLine = cm.ace.session.getFoldLine(i);\n        if (foldLine) {\n            if (i + dir > foldLine.start.row && i + dir < foldLine.end.row)\n                dir = (dir > 0 ? foldLine.end.row : foldLine.start.row) - i;\n        }\n    }\n    if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n            skipFold(i);\n            if (isBoundary(i, dir)) {\n                repeat--;\n            }\n            i += dir;\n        }\n        return new Pos(i, 0);\n    }\n    var vim = cm.state.vim;\n    if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n            if (!inclusive || anchor.line != line) {\n                line += 1;\n            }\n        }\n    }\n    var startState = isEmpty(line);\n    for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n            if (!inclusive || isEmpty(i) != startState) {\n                repeat--;\n            }\n        }\n    }\n    end = new Pos(i, 0);\n    if (i > max && !startState) {\n        startState = true;\n    }\n    else {\n        inclusive = false;\n    }\n    for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n            if (isBoundary(i, -1, true)) {\n                break;\n            }\n        }\n    }\n    start = new Pos(i, 0);\n    return { start: start, end: end };\n}\nfunction getSentence(cm, cur, repeat, dir, inclusive /*includes whitespace*/) {\n    function nextChar(curr) {\n        if (curr.pos + curr.dir < 0 || curr.pos + curr.dir >= curr.line.length) {\n            curr.line = null;\n        }\n        else {\n            curr.pos += curr.dir;\n        }\n    }\n    function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var curr = {\n            line: line,\n            ln: ln,\n            pos: pos,\n            dir: dir,\n        };\n        if (curr.line === \"\") {\n            return { ln: curr.ln, pos: curr.pos };\n        }\n        var lastSentencePos = curr.pos;\n        nextChar(curr);\n        while (curr.line !== null) {\n            lastSentencePos = curr.pos;\n            if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n                if (!inclusive) {\n                    return { ln: curr.ln, pos: curr.pos + 1 };\n                }\n                else {\n                    nextChar(curr);\n                    while (curr.line !== null) {\n                        if (isWhiteSpaceString(curr.line[curr.pos])) {\n                            lastSentencePos = curr.pos;\n                            nextChar(curr);\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                    return { ln: curr.ln, pos: lastSentencePos + 1 };\n                }\n            }\n            nextChar(curr);\n        }\n        return { ln: curr.ln, pos: lastSentencePos + 1 };\n    }\n    function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var curr = {\n            line: line,\n            ln: ln,\n            pos: pos,\n            dir: dir,\n        };\n        if (curr.line === \"\") {\n            return { ln: curr.ln, pos: curr.pos };\n        }\n        var lastSentencePos = curr.pos;\n        nextChar(curr);\n        while (curr.line !== null) {\n            if (!isWhiteSpaceString(curr.line[curr.pos]) && !isEndOfSentenceSymbol(curr.line[curr.pos])) {\n                lastSentencePos = curr.pos;\n            }\n            else if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n                if (!inclusive) {\n                    return { ln: curr.ln, pos: lastSentencePos };\n                }\n                else {\n                    if (isWhiteSpaceString(curr.line[curr.pos + 1])) {\n                        return { ln: curr.ln, pos: curr.pos + 1 };\n                    }\n                    else {\n                        return { ln: curr.ln, pos: lastSentencePos };\n                    }\n                }\n            }\n            nextChar(curr);\n        }\n        curr.line = line;\n        if (inclusive && isWhiteSpaceString(curr.line[curr.pos])) {\n            return { ln: curr.ln, pos: curr.pos };\n        }\n        else {\n            return { ln: curr.ln, pos: lastSentencePos };\n        }\n    }\n    var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n    };\n    while (repeat > 0) {\n        if (dir < 0) {\n            curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n            curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n    }\n    return new Pos(curr_index.ln, curr_index.pos);\n}\nfunction findSentence(cm, cur, repeat, dir) {\n    function nextChar(cm, idx) {\n        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n            idx.ln += idx.dir;\n            if (!isLine(cm, idx.ln)) {\n                idx.line = null;\n                idx.ln = null;\n                idx.pos = null;\n                return;\n            }\n            idx.line = cm.getLine(idx.ln);\n            idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;\n        }\n        else {\n            idx.pos += idx.dir;\n        }\n    }\n    function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var stop = (line === \"\");\n        var curr = {\n            line: line,\n            ln: ln,\n            pos: pos,\n            dir: dir,\n        };\n        var last_valid = {\n            ln: curr.ln,\n            pos: curr.pos,\n        };\n        var skip_empty_lines = (curr.line === \"\");\n        nextChar(cm, curr);\n        while (curr.line !== null) {\n            last_valid.ln = curr.ln;\n            last_valid.pos = curr.pos;\n            if (curr.line === \"\" && !skip_empty_lines) {\n                return { ln: curr.ln, pos: curr.pos, };\n            }\n            else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n                return { ln: curr.ln, pos: curr.pos, };\n            }\n            else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n                && !stop\n                && (curr.pos === curr.line.length - 1\n                    || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n                stop = true;\n            }\n            nextChar(cm, curr);\n        }\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for (var i = line.length - 1; i >= 0; --i) {\n            if (!isWhiteSpaceString(line[i])) {\n                last_valid.pos = i;\n                break;\n            }\n        }\n        return last_valid;\n    }\n    function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var curr = {\n            line: line,\n            ln: ln,\n            pos: pos,\n            dir: dir,\n        };\n        var last_valid = {\n            ln: curr.ln,\n            pos: null,\n        };\n        var skip_empty_lines = (curr.line === \"\");\n        nextChar(cm, curr);\n        while (curr.line !== null) {\n            if (curr.line === \"\" && !skip_empty_lines) {\n                if (last_valid.pos !== null) {\n                    return last_valid;\n                }\n                else {\n                    return { ln: curr.ln, pos: curr.pos };\n                }\n            }\n            else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n                && last_valid.pos !== null\n                && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n                return last_valid;\n            }\n            else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n                skip_empty_lines = false;\n                last_valid = { ln: curr.ln, pos: curr.pos };\n            }\n            nextChar(cm, curr);\n        }\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for (var i = 0; i < line.length; ++i) {\n            if (!isWhiteSpaceString(line[i])) {\n                last_valid.pos = i;\n                break;\n            }\n        }\n        return last_valid;\n    }\n    var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n    };\n    while (repeat > 0) {\n        if (dir < 0) {\n            curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n            curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n    }\n    return new Pos(curr_index.ln, curr_index.pos);\n}\nfunction selectCompanionObject(cm, head, symb, inclusive) {\n    var cur = head, start, end;\n    var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/,\n        '<': /[<>]/, '>': /[<>]/\n    })[symb];\n    var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{',\n        '<': '<', '>': '<'\n    })[symb];\n    var curChar = cm.getLine(cur.line).charAt(cur.ch);\n    var offset = curChar === openSym ? 1 : 0;\n    start = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, undefined, { 'bracketRegex': bracketRegexp });\n    end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, { 'bracketRegex': bracketRegexp });\n    if (!start || !end)\n        return null;\n    start = start.pos;\n    end = end.pos;\n    if ((start.line == end.line && start.ch > end.ch)\n        || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n    }\n    if (inclusive) {\n        end.ch += 1;\n    }\n    else {\n        start.ch += 1;\n    }\n    return { start: start, end: end };\n}\nfunction findBeginningAndEnd(cm, head, symb, inclusive) {\n    var cur = copyCursor(head);\n    var line = cm.getLine(cur.line);\n    var chars = line.split('');\n    var start, end, i, len;\n    var firstIndex = chars.indexOf(symb);\n    if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n    }\n    else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        var stringAfter = /string/.test(cm.getTokenTypeAt(offsetCursor(head, 0, 1)));\n        var stringBefore = /string/.test(cm.getTokenTypeAt(head));\n        var isStringStart = stringAfter && !stringBefore;\n        if (!isStringStart) {\n            end = cur.ch; // assign end to the current cursor\n            --cur.ch; // make sure to look backwards\n        }\n    }\n    if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n    }\n    else {\n        for (i = cur.ch; i > -1 && !start; i--) {\n            if (chars[i] == symb) {\n                start = i + 1;\n            }\n        }\n    }\n    if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n            if (chars[i] == symb) {\n                end = i;\n            }\n        }\n    }\n    if (!start || !end) {\n        return { start: cur, end: cur };\n    }\n    if (inclusive) {\n        --start;\n        ++end;\n    }\n    return {\n        start: new Pos(cur.line, start),\n        end: new Pos(cur.line, end)\n    };\n}\ndefineOption('pcre', true, 'boolean');\nfunction SearchState() { }\nSearchState.prototype = {\n    getQuery: function () {\n        return vimGlobalState.query;\n    },\n    setQuery: function (query) {\n        vimGlobalState.query = query;\n    },\n    getOverlay: function () {\n        return this.searchOverlay;\n    },\n    setOverlay: function (overlay) {\n        this.searchOverlay = overlay;\n    },\n    isReversed: function () {\n        return vimGlobalState.isReversed;\n    },\n    setReversed: function (reversed) {\n        vimGlobalState.isReversed = reversed;\n    },\n    getScrollbarAnnotate: function () {\n        return this.annotate;\n    },\n    setScrollbarAnnotate: function (annotate) {\n        this.annotate = annotate;\n    }\n};\nfunction getSearchState(cm) {\n    var vim = cm.state.vim;\n    return vim.searchState_ || (vim.searchState_ = new SearchState());\n}\nfunction splitBySlash(argString) {\n    return splitBySeparator(argString, '/');\n}\nfunction findUnescapedSlashes(argString) {\n    return findUnescapedSeparators(argString, '/');\n}\nfunction splitBySeparator(argString, separator) {\n    var slashes = findUnescapedSeparators(argString, separator) || [];\n    if (!slashes.length)\n        return [];\n    var tokens = [];\n    if (slashes[0] !== 0)\n        return;\n    for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n            tokens.push(argString.substring(slashes[i] + 1, slashes[i + 1]));\n    }\n    return tokens;\n}\nfunction findUnescapedSeparators(str, separator) {\n    if (!separator)\n        separator = '/';\n    var escapeNextChar = false;\n    var slashes = [];\n    for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == separator) {\n            slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n    }\n    return slashes;\n}\nfunction translateRegex(str) {\n    var specials = '|(){';\n    var unescape = '}';\n    var escapeNextChar = false;\n    var out = [];\n    for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i + 1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n            if (c !== '\\\\' || !specialComesNext) {\n                out.push(c);\n            }\n            escapeNextChar = false;\n        }\n        else {\n            if (c === '\\\\') {\n                escapeNextChar = true;\n                if (n && unescape.indexOf(n) != -1) {\n                    specialComesNext = true;\n                }\n                if (!specialComesNext || n === '\\\\') {\n                    out.push(c);\n                }\n            }\n            else {\n                out.push(c);\n                if (specialComesNext && n !== '\\\\') {\n                    out.push('\\\\');\n                }\n            }\n        }\n    }\n    return out.join('');\n}\nvar charUnescapes = { '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t' };\nfunction translateRegexReplace(str) {\n    var escapeNextChar = false;\n    var out = [];\n    for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i + 1) || '';\n        if (charUnescapes[c + n]) {\n            out.push(charUnescapes[c + n]);\n            i++;\n        }\n        else if (escapeNextChar) {\n            out.push(c);\n            escapeNextChar = false;\n        }\n        else {\n            if (c === '\\\\') {\n                escapeNextChar = true;\n                if ((isNumber(n) || n === '$')) {\n                    out.push('$');\n                }\n                else if (n !== '/' && n !== '\\\\') {\n                    out.push('\\\\');\n                }\n            }\n            else {\n                if (c === '$') {\n                    out.push('$');\n                }\n                out.push(c);\n                if (n === '/') {\n                    out.push('\\\\');\n                }\n            }\n        }\n    }\n    return out.join('');\n}\nvar unescapes = { '\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t', '\\\\&': '&' };\nfunction unescapeRegexReplace(str) {\n    var stream = new CodeMirror.StringStream(str);\n    var output = [];\n    while (!stream.eol()) {\n        while (stream.peek() && stream.peek() != '\\\\') {\n            output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n            if (stream.match(matcher, true)) {\n                matched = true;\n                output.push(unescapes[matcher]);\n                break;\n            }\n        }\n        if (!matched) {\n            output.push(stream.next());\n        }\n    }\n    return output.join('');\n}\nfunction parseQuery(query, ignoreCase, smartCase) {\n    var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n    lastSearchRegister.setText(query);\n    if (query instanceof RegExp) {\n        return query;\n    }\n    var slashes = findUnescapedSlashes(query);\n    var regexPart;\n    var forceIgnoreCase;\n    if (!slashes.length) {\n        regexPart = query;\n    }\n    else {\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n    }\n    if (!regexPart) {\n        return null;\n    }\n    if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n    }\n    if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n    }\n    var regexp = new RegExp(regexPart, (ignoreCase || forceIgnoreCase) ? 'im' : 'm');\n    return regexp;\n}\nfunction dom(n) {\n    if (typeof n === 'string')\n        n = document.createElement(n);\n    for (var a, i = 1; i < arguments.length; i++) {\n        if (!(a = arguments[i]))\n            continue;\n        if (typeof a !== 'object')\n            a = document.createTextNode(a);\n        if (a.nodeType)\n            n.appendChild(a);\n        else\n            for (var key in a) {\n                if (!Object.prototype.hasOwnProperty.call(a, key))\n                    continue;\n                if (key[0] === '$')\n                    n.style[key.slice(1)] = a[key];\n                else\n                    n.setAttribute(key, a[key]);\n            }\n    }\n    return n;\n}\nfunction showConfirm(cm, template) {\n    var pre = dom('div', { $color: 'red', $whiteSpace: 'pre', class: 'cm-vim-message' }, template);\n    if (cm.openNotification) {\n        cm.openNotification(pre, { bottom: true, duration: 5000 });\n    }\n    else {\n        alert(pre.innerText);\n    }\n}\nfunction makePrompt(prefix, desc) {\n    return dom('div', { $display: 'flex' }, dom('span', { $fontFamily: 'monospace', $whiteSpace: 'pre', $flex: 1 }, prefix, dom('input', { type: 'text', autocorrect: 'off',\n        autocapitalize: 'off', spellcheck: 'false', $width: '100%' })), desc && dom('span', { $color: '#888' }, desc));\n}\nfunction showPrompt(cm, options) {\n    if (keyToKeyStack.length) {\n        if (!options.value)\n            options.value = '';\n        virtualPrompt = options;\n        return;\n    }\n    var template = makePrompt(options.prefix, options.desc);\n    if (cm.openDialog) {\n        cm.openDialog(template, options.onClose, {\n            onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n            bottom: true, selectValueOnOpen: false, value: options.value\n        });\n    }\n    else {\n        var shortText = '';\n        if (typeof options.prefix != \"string\" && options.prefix)\n            shortText += options.prefix.textContent;\n        if (options.desc)\n            shortText += \" \" + options.desc;\n        options.onClose(prompt(shortText, ''));\n    }\n}\nfunction regexEqual(r1, r2) {\n    if (r1 instanceof RegExp && r2 instanceof RegExp) {\n        var props = ['global', 'multiline', 'ignoreCase', 'source'];\n        for (var i = 0; i < props.length; i++) {\n            var prop = props[i];\n            if (r1[prop] !== r2[prop]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nfunction updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n    if (!rawQuery) {\n        return;\n    }\n    var state = getSearchState(cm);\n    var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n    if (!query) {\n        return;\n    }\n    highlightSearchMatches(cm, query);\n    if (regexEqual(query, state.getQuery())) {\n        return query;\n    }\n    state.setQuery(query);\n    return query;\n}\nfunction searchOverlay(query) {\n    if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n    }\n    return {\n        token: function (stream) {\n            if (matchSol && !stream.sol()) {\n                stream.skipToEnd();\n                return;\n            }\n            var match = stream.match(query, false);\n            if (match) {\n                if (match[0].length == 0) {\n                    stream.next();\n                    return 'searching';\n                }\n                if (!stream.sol()) {\n                    stream.backUp(1);\n                    if (!query.exec(stream.next() + match[0])) {\n                        stream.next();\n                        return null;\n                    }\n                }\n                stream.match(query);\n                return 'searching';\n            }\n            while (!stream.eol()) {\n                stream.next();\n                if (stream.match(query, false))\n                    break;\n            }\n        },\n        query: query\n    };\n}\nvar highlightTimeout = 0;\nfunction highlightSearchMatches(cm, query) {\n    clearTimeout(highlightTimeout);\n    var searchState = getSearchState(cm);\n    searchState.highlightTimeout = highlightTimeout;\n    highlightTimeout = setTimeout(function () {\n        if (!cm.state.vim)\n            return;\n        var searchState = getSearchState(cm);\n        searchState.highlightTimeout = null;\n        var overlay = searchState.getOverlay();\n        if (!overlay || query != overlay.query) {\n            if (overlay) {\n                cm.removeOverlay(overlay);\n            }\n            overlay = searchOverlay(query);\n            cm.addOverlay(overlay);\n            if (cm.showMatchesOnScrollbar) {\n                if (searchState.getScrollbarAnnotate()) {\n                    searchState.getScrollbarAnnotate().clear();\n                }\n                searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n            }\n            searchState.setOverlay(overlay);\n        }\n    }, 50);\n}\nfunction findNext(cm, prev, query, repeat) {\n    if (repeat === undefined) {\n        repeat = 1;\n    }\n    return cm.operation(function () {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n            var found = cursor.find(prev);\n            if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n                var lastEndPos = prev ? cursor.from() : cursor.to();\n                found = cursor.find(prev);\n                if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n                    if (cm.getLine(lastEndPos.line).length == lastEndPos.ch)\n                        found = cursor.find(prev);\n                }\n            }\n            if (!found) {\n                cursor = cm.getSearchCursor(query, (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));\n                if (!cursor.find(prev)) {\n                    return;\n                }\n            }\n        }\n        return cursor.from();\n    });\n}\nfunction findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n    if (repeat === undefined) {\n        repeat = 1;\n    }\n    return cm.operation(function () {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        var found = cursor.find(!prev);\n        if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n            cursor.find(!prev);\n        }\n        for (var i = 0; i < repeat; i++) {\n            found = cursor.find(prev);\n            if (!found) {\n                cursor = cm.getSearchCursor(query, (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));\n                if (!cursor.find(prev)) {\n                    return;\n                }\n            }\n        }\n        return [cursor.from(), cursor.to()];\n    });\n}\nfunction clearSearchHighlight(cm) {\n    var state = getSearchState(cm);\n    if (state.highlightTimeout) {\n        clearTimeout(state.highlightTimeout);\n        state.highlightTimeout = null;\n    }\n    cm.removeOverlay(getSearchState(cm).getOverlay());\n    state.setOverlay(null);\n    if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n    }\n}\nfunction isInRange(pos, start, end) {\n    if (typeof pos != 'number') {\n        pos = pos.line;\n    }\n    if (start instanceof Array) {\n        return inArray(pos, start);\n    }\n    else {\n        if (typeof end == 'number') {\n            return (pos >= start && pos <= end);\n        }\n        else {\n            return pos == start;\n        }\n    }\n}\nfunction getUserVisibleLines(cm) {\n    var renderer = cm.ace.renderer;\n    return {\n        top: renderer.getFirstFullyVisibleRow(),\n        bottom: renderer.getLastFullyVisibleRow()\n    };\n}\nfunction getMarkPos(cm, vim, markName) {\n    if (markName == '\\'' || markName == '`') {\n        return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);\n    }\n    else if (markName == '.') {\n        return getLastEditPos(cm);\n    }\n    var mark = vim.marks[markName];\n    return mark && mark.find();\n}\nfunction getLastEditPos(cm) {\n    if (cm.getLastEditEnd) {\n        return cm.getLastEditEnd();\n    }\n    var done = cm.doc.history.done;\n    for (var i = done.length; i--;) {\n        if (done[i].changes) {\n            return copyCursor(done[i].changes[0].to);\n        }\n    }\n}\nvar ExCommandDispatcher = function () {\n    this.buildCommandMap_();\n};\nExCommandDispatcher.prototype = {\n    processCommand: function (cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n            cm.curOp.isVimOp = true;\n            that._processCommand(cm, input, opt_params);\n        });\n    },\n    _processCommand: function (cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        var inputStream = new CodeMirror.StringStream(input);\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n            this.parseInput_(cm, inputStream, params);\n        }\n        catch (e) {\n            showConfirm(cm, e.toString());\n            throw e;\n        }\n        if (vim.visualMode) {\n            exitVisualMode(cm);\n        }\n        var command;\n        var commandName;\n        if (!params.commandName) {\n            if (params.line !== undefined) {\n                commandName = 'move';\n            }\n        }\n        else {\n            command = this.matchCommand_(params.commandName);\n            if (command) {\n                commandName = command.name;\n                if (command.excludeFromCommandHistory) {\n                    commandHistoryRegister.setText(previousCommand);\n                }\n                this.parseCommandArgs_(inputStream, params, command);\n                if (command.type == 'exToKey') {\n                    doKeyToKey(cm, command.toKeys, command);\n                    return;\n                }\n                else if (command.type == 'exToEx') {\n                    this.processCommand(cm, command.toInput);\n                    return;\n                }\n            }\n        }\n        if (!commandName) {\n            showConfirm(cm, 'Not an editor command \":' + input + '\"');\n            return;\n        }\n        try {\n            exCommands[commandName](cm, params);\n            if ((!command || !command.possiblyAsync) && params.callback) {\n                params.callback();\n            }\n        }\n        catch (e) {\n            showConfirm(cm, e.toString());\n            throw e;\n        }\n    },\n    parseInput_: function (cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        if (inputStream.eat('%')) {\n            result.line = cm.firstLine();\n            result.lineEnd = cm.lastLine();\n        }\n        else {\n            result.line = this.parseLineSpec_(cm, inputStream);\n            if (result.line !== undefined && inputStream.eat(',')) {\n                result.lineEnd = this.parseLineSpec_(cm, inputStream);\n            }\n        }\n        if (result.line == undefined) {\n            if (cm.state.vim.visualMode) {\n                var pos = getMarkPos(cm, cm.state.vim, '<');\n                result.selectionLine = pos && pos.line;\n                pos = getMarkPos(cm, cm.state.vim, '>');\n                result.selectionLineEnd = pos && pos.line;\n            }\n            else {\n                result.selectionLine = cm.getCursor().line;\n            }\n        }\n        else {\n            result.selectionLine = result.line;\n            result.selectionLineEnd = result.lineEnd;\n        }\n        var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n        if (commandMatch) {\n            result.commandName = commandMatch[1];\n        }\n        else {\n            result.commandName = inputStream.match(/.*/)[0];\n        }\n        return result;\n    },\n    parseLineSpec_: function (cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n            return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n            case '.':\n                return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n            case '$':\n                return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n            case '\\'':\n                var markName = inputStream.next();\n                var markPos = getMarkPos(cm, cm.state.vim, markName);\n                if (!markPos)\n                    throw new Error('Mark not set');\n                return this.parseLineSpecOffset_(inputStream, markPos.line);\n            case '-':\n            case '+':\n                inputStream.backUp(1);\n                return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n            default:\n                inputStream.backUp(1);\n                return undefined;\n        }\n    },\n    parseLineSpecOffset_: function (inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n        if (offsetMatch) {\n            var offset = parseInt(offsetMatch[2], 10);\n            if (offsetMatch[1] == \"-\") {\n                line -= offset;\n            }\n            else {\n                line += offset;\n            }\n        }\n        return line;\n    },\n    parseCommandArgs_: function (inputStream, params, command) {\n        if (inputStream.eol()) {\n            return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n            params.args = args;\n        }\n    },\n    matchCommand_: function (commandName) {\n        for (var i = commandName.length; i > 0; i--) {\n            var prefix = commandName.substring(0, i);\n            if (this.commandMap_[prefix]) {\n                var command = this.commandMap_[prefix];\n                if (command.name.indexOf(commandName) === 0) {\n                    return command;\n                }\n            }\n        }\n        return null;\n    },\n    buildCommandMap_: function () {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n            var command = defaultExCommandMap[i];\n            var key = command.shortName || command.name;\n            this.commandMap_[key] = command;\n        }\n    },\n    map: function (lhs, rhs, ctx, noremap) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n            if (ctx) {\n                throw Error('Mode not supported for ex mappings');\n            }\n            var commandName = lhs.substring(1);\n            if (rhs != ':' && rhs.charAt(0) == ':') {\n                this.commandMap_[commandName] = {\n                    name: commandName,\n                    type: 'exToEx',\n                    toInput: rhs.substring(1),\n                    user: true\n                };\n            }\n            else {\n                this.commandMap_[commandName] = {\n                    name: commandName,\n                    type: 'exToKey',\n                    toKeys: rhs,\n                    user: true\n                };\n            }\n        }\n        else {\n            var mapping = {\n                keys: lhs,\n                type: 'keyToKey',\n                toKeys: rhs,\n                noremap: !!noremap\n            };\n            if (ctx) {\n                mapping.context = ctx;\n            }\n            defaultKeymap.unshift(mapping);\n        }\n    },\n    unmap: function (lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n            if (ctx) {\n                throw Error('Mode not supported for ex mappings');\n            }\n            var commandName = lhs.substring(1);\n            if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n                delete this.commandMap_[commandName];\n                return true;\n            }\n        }\n        else {\n            var keys = lhs;\n            for (var i = 0; i < defaultKeymap.length; i++) {\n                if (keys == defaultKeymap[i].keys\n                    && defaultKeymap[i].context === ctx) {\n                    defaultKeymap.splice(i, 1);\n                    return true;\n                }\n            }\n        }\n    }\n};\nvar exCommands = {\n    colorscheme: function (cm, params) {\n        if (!params.args || params.args.length < 1) {\n            showConfirm(cm, cm.getOption('theme'));\n            return;\n        }\n        cm.setOption('theme', params.args[0]);\n    },\n    map: function (cm, params, ctx, defaultOnly) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n            if (cm) {\n                showConfirm(cm, 'Invalid mapping: ' + params.input);\n            }\n            return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx, defaultOnly);\n    },\n    imap: function (cm, params) { this.map(cm, params, 'insert'); },\n    nmap: function (cm, params) { this.map(cm, params, 'normal'); },\n    vmap: function (cm, params) { this.map(cm, params, 'visual'); },\n    omap: function (cm, params) { this.map(cm, params, 'operatorPending'); },\n    noremap: function (cm, params) { this.map(cm, params, undefined, true); },\n    inoremap: function (cm, params) { this.map(cm, params, 'insert', true); },\n    nnoremap: function (cm, params) { this.map(cm, params, 'normal', true); },\n    vnoremap: function (cm, params) { this.map(cm, params, 'visual', true); },\n    onoremap: function (cm, params) { this.map(cm, params, 'operatorPending', true); },\n    unmap: function (cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {\n            if (cm) {\n                showConfirm(cm, 'No such mapping: ' + params.input);\n            }\n        }\n    },\n    mapclear: function (cm, params) { vimApi.mapclear(); },\n    imapclear: function (cm, params) { vimApi.mapclear('insert'); },\n    nmapclear: function (cm, params) { vimApi.mapclear('normal'); },\n    vmapclear: function (cm, params) { vimApi.mapclear('visual'); },\n    omapclear: function (cm, params) { vimApi.mapclear('operatorPending'); },\n    move: function (cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n                linewise: true },\n            repeatOverride: params.line + 1\n        });\n    },\n    set: function (cm, params) {\n        var setArgs = params.args;\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n            if (cm) {\n                showConfirm(cm, 'Invalid mapping: ' + params.input);\n            }\n            return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n        var forceToggle = false;\n        if (optionName.charAt(optionName.length - 1) == '?') {\n            if (value) {\n                throw Error('Trailing characters: ' + params.argString);\n            }\n            optionName = optionName.substring(0, optionName.length - 1);\n            forceGet = true;\n        }\n        else if (optionName.charAt(optionName.length - 1) == '!') {\n            optionName = optionName.substring(0, optionName.length - 1);\n            forceToggle = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n            optionName = optionName.substring(2);\n            value = false;\n        }\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean) {\n            if (forceToggle) {\n                value = !getOption(optionName, cm, setCfg);\n            }\n            else if (value == undefined) {\n                value = true;\n            }\n        }\n        if (!optionIsBoolean && value === undefined || forceGet) {\n            var oldValue = getOption(optionName, cm, setCfg);\n            if (oldValue instanceof Error) {\n                showConfirm(cm, oldValue.message);\n            }\n            else if (oldValue === true || oldValue === false) {\n                showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n            }\n            else {\n                showConfirm(cm, '  ' + optionName + '=' + oldValue);\n            }\n        }\n        else {\n            var setOptionReturn = setOption(optionName, value, cm, setCfg);\n            if (setOptionReturn instanceof Error) {\n                showConfirm(cm, setOptionReturn.message);\n            }\n        }\n    },\n    setlocal: function (cm, params) {\n        params.setCfg = { scope: 'local' };\n        this.set(cm, params);\n    },\n    setglobal: function (cm, params) {\n        params.setCfg = { scope: 'global' };\n        this.set(cm, params);\n    },\n    registers: function (cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------\\n\\n';\n        if (!regArgs) {\n            for (var registerName in registers) {\n                var text = registers[registerName].toString();\n                if (text.length) {\n                    regInfo += '\"' + registerName + '    ' + text + '\\n';\n                }\n            }\n        }\n        else {\n            var registerName;\n            regArgs = regArgs.join('');\n            for (var i = 0; i < regArgs.length; i++) {\n                registerName = regArgs.charAt(i);\n                if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n                    continue;\n                }\n                var register = registers[registerName] || new Register();\n                regInfo += '\"' + registerName + '    ' + register.toString() + '\\n';\n            }\n        }\n        showConfirm(cm, regInfo);\n    },\n    sort: function (cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n            if (params.argString) {\n                var args = new CodeMirror.StringStream(params.argString);\n                if (args.eat('!')) {\n                    reverse = true;\n                }\n                if (args.eol()) {\n                    return;\n                }\n                if (!args.eatSpace()) {\n                    return 'Invalid arguments';\n                }\n                var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n                if (!opts && !args.eol()) {\n                    return 'Invalid arguments';\n                }\n                if (opts[1]) {\n                    ignoreCase = opts[1].indexOf('i') != -1;\n                    unique = opts[1].indexOf('u') != -1;\n                    var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n                    var hex = opts[1].indexOf('x') != -1 && 1;\n                    var octal = opts[1].indexOf('o') != -1 && 1;\n                    if (decimal + hex + octal > 1) {\n                        return 'Invalid arguments';\n                    }\n                    number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n                }\n                if (opts[2]) {\n                    pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n                }\n            }\n        }\n        var err = parseArgs();\n        if (err) {\n            showConfirm(cm, err + ': ' + params.argString);\n            return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) {\n            return;\n        }\n        var curStart = new Pos(lineStart, 0);\n        var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern :\n            (number == 'decimal') ? /(-?)([\\d]+)/ :\n                (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n                    (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number || pattern) {\n            for (var i = 0; i < text.length; i++) {\n                var matchPart = pattern ? text[i].match(pattern) : null;\n                if (matchPart && matchPart[0] != '') {\n                    numPart.push(matchPart);\n                }\n                else if (!pattern && numberRegex.exec(text[i])) {\n                    numPart.push(text[i]);\n                }\n                else {\n                    textPart.push(text[i]);\n                }\n            }\n        }\n        else {\n            textPart = text;\n        }\n        function compareFn(a, b) {\n            if (reverse) {\n                var tmp;\n                tmp = a;\n                a = b;\n                b = tmp;\n            }\n            if (ignoreCase) {\n                a = a.toLowerCase();\n                b = b.toLowerCase();\n            }\n            var anum = number && numberRegex.exec(a);\n            var bnum = number && numberRegex.exec(b);\n            if (!anum) {\n                return a < b ? -1 : 1;\n            }\n            anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n            bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n            return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n            if (reverse) {\n                var tmp;\n                tmp = a;\n                a = b;\n                b = tmp;\n            }\n            if (ignoreCase) {\n                a[0] = a[0].toLowerCase();\n                b[0] = b[0].toLowerCase();\n            }\n            return (a[0] < b[0]) ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n            for (var i = 0; i < numPart.length; i++) {\n                numPart[i] = numPart[i].input;\n            }\n        }\n        else if (!number) {\n            textPart.sort(compareFn);\n        }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n            var textOld = text;\n            var lastLine;\n            text = [];\n            for (var i = 0; i < textOld.length; i++) {\n                if (textOld[i] != lastLine) {\n                    text.push(textOld[i]);\n                }\n                lastLine = textOld[i];\n            }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n    },\n    vglobal: function (cm, params) {\n        this.global(cm, params);\n    },\n    normal: function (cm, params) {\n        var argString = params.argString;\n        if (argString && argString[0] == '!') {\n            argString = argString.slice(1);\n            noremap = true;\n        }\n        argString = argString.trimStart();\n        if (!argString) {\n            showConfirm(cm, 'Argument is required.');\n            return;\n        }\n        var line = params.line;\n        if (typeof line == 'number') {\n            var lineEnd = isNaN(params.lineEnd) ? line : params.lineEnd;\n            for (var i = line; i <= lineEnd; i++) {\n                cm.setCursor(i, 0);\n                doKeyToKey(cm, params.argString.trimStart());\n                if (cm.state.vim.insertMode) {\n                    exitInsertMode(cm, true);\n                }\n            }\n        }\n        else {\n            doKeyToKey(cm, params.argString.trimStart());\n            if (cm.state.vim.insertMode) {\n                exitInsertMode(cm, true);\n            }\n        }\n    },\n    global: function (cm, params) {\n        var argString = params.argString;\n        if (!argString) {\n            showConfirm(cm, 'Regular Expression missing from global');\n            return;\n        }\n        var inverted = params.commandName[0] === 'v';\n        if (argString[0] === '!' && params.commandName[0] === 'g') {\n            inverted = true;\n            argString = argString.slice(1);\n        }\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n            regexPart = tokens[0];\n            cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n            try {\n                updateSearchQuery(cm, regexPart, true /** ignoreCase */, true /** smartCase */);\n            }\n            catch (e) {\n                showConfirm(cm, 'Invalid regex: ' + regexPart);\n                return;\n            }\n        }\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [];\n        for (var i = lineStart; i <= lineEnd; i++) {\n            var line = cm.getLine(i);\n            var matched = query.test(line);\n            if (matched !== inverted) {\n                matchedLines.push(cmd ? cm.getLineHandle(i) : line);\n            }\n        }\n        if (!cmd) {\n            showConfirm(cm, matchedLines.join('\\n'));\n            return;\n        }\n        var index = 0;\n        var nextCommand = function () {\n            if (index < matchedLines.length) {\n                var lineHandle = matchedLines[index++];\n                var lineNum = cm.getLineNumber(lineHandle);\n                if (lineNum == null) {\n                    nextCommand();\n                    return;\n                }\n                var command = (lineNum + 1) + cmd;\n                exCommandDispatcher.processCommand(cm, command, {\n                    callback: nextCommand\n                });\n            }\n            else if (cm.releaseLineHandles) {\n                cm.releaseLineHandles();\n            }\n        };\n        nextCommand();\n    },\n    substitute: function (cm, params) {\n        if (!cm.getSearchCursor) {\n            throw new Error('Search feature not available. Requires searchcursor.js or ' +\n                'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n            regexPart = tokens[0];\n            if (getOption('pcre') && regexPart !== '') {\n                regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n            }\n            replacePart = tokens[1];\n            if (replacePart !== undefined) {\n                if (getOption('pcre')) {\n                    replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g, \"$1$$&\"));\n                }\n                else {\n                    replacePart = translateRegexReplace(replacePart);\n                }\n                vimGlobalState.lastSubstituteReplacePart = replacePart;\n            }\n            trailing = tokens[2] ? tokens[2].split(' ') : [];\n        }\n        else {\n            if (argString && argString.length) {\n                showConfirm(cm, 'Substitutions should be of the form ' +\n                    ':s/pattern/replace/');\n                return;\n            }\n        }\n        if (trailing) {\n            flagsPart = trailing[0];\n            count = parseInt(trailing[1]);\n            if (flagsPart) {\n                if (flagsPart.indexOf('c') != -1) {\n                    confirm = true;\n                }\n                if (flagsPart.indexOf('g') != -1) {\n                    global = true;\n                }\n                if (getOption('pcre')) {\n                    regexPart = regexPart + '/' + flagsPart;\n                }\n                else {\n                    regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n                }\n            }\n        }\n        if (regexPart) {\n            try {\n                updateSearchQuery(cm, regexPart, true /** ignoreCase */, true /** smartCase */);\n            }\n            catch (e) {\n                showConfirm(cm, 'Invalid regex: ' + regexPart);\n                return;\n            }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n            showConfirm(cm, 'No previous substitute regular expression');\n            return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n            lineEnd = Infinity;\n        }\n        if (count) {\n            lineStart = lineEnd;\n            lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n    },\n    startinsert: function (cm, params) {\n        doKeyToKey(cm, params.argString == '!' ? 'A' : 'i', {});\n    },\n    redo: CodeMirror.commands.redo,\n    undo: CodeMirror.commands.undo,\n    write: function (cm) {\n        if (CodeMirror.commands.save) {\n            CodeMirror.commands.save(cm);\n        }\n        else if (cm.save) {\n            cm.save();\n        }\n    },\n    nohlsearch: function (cm) {\n        clearSearchHighlight(cm);\n    },\n    yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText('0', 'yank', lineText, true, true);\n    },\n    delete: function (cm, params) {\n        var line = params.selectionLine;\n        var lineEnd = isNaN(params.selectionLineEnd) ? line : params.selectionLineEnd;\n        operators.delete(cm, { linewise: true }, [\n            { anchor: new Pos(line, 0),\n                head: new Pos(lineEnd + 1, 0) }\n        ]);\n    },\n    join: function (cm, params) {\n        var line = params.selectionLine;\n        var lineEnd = isNaN(params.selectionLineEnd) ? line : params.selectionLineEnd;\n        cm.setCursor(new Pos(line, 0));\n        actions.joinLines(cm, { repeat: lineEnd - line }, cm.state.vim);\n    },\n    delmarks: function (cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n            showConfirm(cm, 'Argument required');\n            return;\n        }\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n            stream.eatSpace();\n            var count = stream.pos;\n            if (!stream.match(/[a-zA-Z]/, false)) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n            }\n            var sym = stream.next();\n            if (stream.match('-', true)) {\n                if (!stream.match(/[a-zA-Z]/, false)) {\n                    showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                    return;\n                }\n                var startMark = sym;\n                var finishMark = stream.next();\n                if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                    isUpperCase(startMark) && isUpperCase(finishMark)) {\n                    var start = startMark.charCodeAt(0);\n                    var finish = finishMark.charCodeAt(0);\n                    if (start >= finish) {\n                        showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                        return;\n                    }\n                    for (var j = 0; j <= finish - start; j++) {\n                        var mark = String.fromCharCode(start + j);\n                        delete state.marks[mark];\n                    }\n                }\n                else {\n                    showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n                    return;\n                }\n            }\n            else {\n                delete state.marks[sym];\n            }\n        }\n    }\n};\nvar exCommandDispatcher = new ExCommandDispatcher();\nfunction doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query, replaceWith, callback) {\n    cm.state.vim.exMode = true;\n    var done = false;\n    var lastPos, modifiedLineNumber, joined;\n    function replaceAll() {\n        cm.operation(function () {\n            while (!done) {\n                replace();\n                next();\n            }\n            stop();\n        });\n    }\n    function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        var unmodifiedLineNumber = searchCursor.to().line;\n        searchCursor.replace(newText);\n        modifiedLineNumber = searchCursor.to().line;\n        lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n        joined = modifiedLineNumber < unmodifiedLineNumber;\n    }\n    function findNextValidMatch() {\n        var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n        var match = searchCursor.findNext();\n        if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n            match = searchCursor.findNext();\n        }\n        return match;\n    }\n    function next() {\n        while (findNextValidMatch() &&\n            isInRange(searchCursor.from(), lineStart, lineEnd)) {\n            if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n                continue;\n            }\n            cm.scrollIntoView(searchCursor.from(), 30);\n            cm.setSelection(searchCursor.from(), searchCursor.to());\n            lastPos = searchCursor.from();\n            done = false;\n            return;\n        }\n        done = true;\n    }\n    function stop(close) {\n        if (close) {\n            close();\n        }\n        cm.focus();\n        if (lastPos) {\n            cm.setCursor(lastPos);\n            var vim = cm.state.vim;\n            vim.exMode = false;\n            vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) {\n            callback();\n        }\n    }\n    function onPromptKeyDown(e, _value, close) {\n        CodeMirror.e_stop(e);\n        var keyName = vimKeyFromEvent(e);\n        switch (keyName) {\n            case 'y':\n                replace();\n                next();\n                break;\n            case 'n':\n                next();\n                break;\n            case 'a':\n                var savedCallback = callback;\n                callback = undefined;\n                cm.operation(replaceAll);\n                callback = savedCallback;\n                break;\n            case 'l':\n                replace();\n            case 'q':\n            case '<Esc>':\n            case '<C-c>':\n            case '<C-[>':\n                stop(close);\n                break;\n        }\n        if (done) {\n            stop(close);\n        }\n        return true;\n    }\n    next();\n    if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n    }\n    if (!confirm) {\n        replaceAll();\n        if (callback) {\n            callback();\n        }\n        return;\n    }\n    showPrompt(cm, {\n        prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),\n        onKeyDown: onPromptKeyDown\n    });\n}\nfunction exitInsertMode(cm, keepCursor) {\n    var vim = cm.state.vim;\n    var macroModeState = vimGlobalState.macroModeState;\n    var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n    var isPlaying = macroModeState.isPlaying;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    if (!isPlaying) {\n        cm.off('change', onChange);\n        if (vim.insertEnd)\n            vim.insertEnd.clear();\n        vim.insertEnd = null;\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n    }\n    if (!isPlaying && vim.insertModeRepeat > 1) {\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1, true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n    }\n    delete vim.insertModeRepeat;\n    vim.insertMode = false;\n    if (!keepCursor) {\n        cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1);\n    }\n    cm.setOption('keyMap', 'vim');\n    cm.setOption('disableInput', true);\n    cm.toggleOverwrite(false); // exit replace mode if we were in it.\n    insertModeChangeRegister.setText(lastChange.changes.join(''));\n    CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"normal\" });\n    if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n    }\n}\nfunction _mapCommand(command) {\n    defaultKeymap.unshift(command);\n}\nfunction mapCommand(keys, type, name, args, extra) {\n    var command = { keys: keys, type: type };\n    command[type] = name;\n    command[type + \"Args\"] = args;\n    for (var key in extra)\n        command[key] = extra[key];\n    _mapCommand(command);\n}\ndefineOption('insertModeEscKeysTimeout', 200, 'number');\nfunction executeMacroRegister(cm, vim, macroModeState, registerName) {\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (registerName == ':') {\n        if (register.keyBuffer[0]) {\n            exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n    }\n    var keyBuffer = register.keyBuffer;\n    var imc = 0;\n    macroModeState.isPlaying = true;\n    macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n    for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n            key = match[0];\n            text = text.substring(match.index + key.length);\n            vimApi.handleKey(cm, key, 'macro');\n            if (vim.insertMode) {\n                var changes = register.insertModeChanges[imc++].changes;\n                vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                    changes;\n                repeatInsertModeChanges(cm, changes, 1);\n                exitInsertMode(cm);\n            }\n        }\n    }\n    macroModeState.isPlaying = false;\n}\nfunction logKey(macroModeState, key) {\n    if (macroModeState.isPlaying) {\n        return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register) {\n        register.pushText(key);\n    }\n}\nfunction logInsertModeChange(macroModeState) {\n    if (macroModeState.isPlaying) {\n        return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n    }\n}\nfunction logSearchQuery(macroModeState, query) {\n    if (macroModeState.isPlaying) {\n        return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n    }\n}\nfunction onChange(cm, changeObj) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    if (!macroModeState.isPlaying) {\n        var vim = cm.state.vim;\n        while (changeObj) {\n            lastChange.expectCursorActivityForChange = true;\n            if (lastChange.ignoreCount > 1) {\n                lastChange.ignoreCount--;\n            }\n            else if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n                || changeObj.origin === undefined /* only in testing */) {\n                var selectionCount = cm.listSelections().length;\n                if (selectionCount > 1)\n                    lastChange.ignoreCount = selectionCount;\n                var text = changeObj.text.join('\\n');\n                if (lastChange.maybeReset) {\n                    lastChange.changes = [];\n                    lastChange.maybeReset = false;\n                }\n                if (text) {\n                    if (cm.state.overwrite && !/\\n/.test(text)) {\n                        lastChange.changes.push([text]);\n                    }\n                    else {\n                        if (text.length > 1) {\n                            var insertEnd = vim && vim.insertEnd && vim.insertEnd.find();\n                            var cursor = cm.getCursor();\n                            if (insertEnd && insertEnd.line == cursor.line) {\n                                var offset = insertEnd.ch - cursor.ch;\n                                if (offset > 0 && offset < text.length) {\n                                    lastChange.changes.push([text, offset]);\n                                    text = '';\n                                }\n                            }\n                        }\n                        if (text)\n                            lastChange.changes.push(text);\n                    }\n                }\n            }\n            changeObj = changeObj.next;\n        }\n    }\n}\nfunction onCursorActivity(cm) {\n    var vim = cm.state.vim;\n    if (vim.insertMode) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) {\n            return;\n        }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n            lastChange.expectCursorActivityForChange = false;\n        }\n        else {\n            lastChange.maybeReset = true;\n            if (vim.insertEnd)\n                vim.insertEnd.clear();\n            vim.insertEnd = cm.setBookmark(cm.getCursor(), { insertLeft: true });\n        }\n    }\n    else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n    }\n}\nfunction handleExternalSelection(cm, vim, keepHPos) {\n    var anchor = cm.getCursor('anchor');\n    var head = cm.getCursor('head');\n    if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n    }\n    else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"visual\" });\n    }\n    if (vim.visualMode) {\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n            anchor: anchor,\n            head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n    }\n    else if (!vim.insertMode && !keepHPos) {\n        vim.lastHPos = cm.getCursor().ch;\n    }\n}\nfunction InsertModeKey(keyName, e) {\n    this.keyName = keyName;\n    this.key = e.key;\n    this.ctrlKey = e.ctrlKey;\n    this.altKey = e.altKey;\n    this.metaKey = e.metaKey;\n    this.shiftKey = e.shiftKey;\n}\nfunction onKeyEventTargetKeyDown(e) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    var keyName = CodeMirror.keyName ? CodeMirror.keyName(e) : e.key;\n    if (!keyName) {\n        return;\n    }\n    if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        if (lastChange.maybeReset) {\n            lastChange.changes = [];\n            lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName, e));\n    }\n}\nfunction repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n    var macroModeState = vimGlobalState.macroModeState;\n    macroModeState.isPlaying = true;\n    var isAction = !!vim.lastEditActionCommand;\n    var cachedInputState = vim.inputState;\n    function repeatCommand() {\n        if (isAction) {\n            commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        }\n        else {\n            commandDispatcher.evalInput(cm, vim);\n        }\n    }\n    function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n            repeat = !vim.lastEditActionCommand ? 1 : repeat;\n            var changeObject = macroModeState.lastInsertModeChanges;\n            repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n    }\n    vim.inputState = vim.lastEditInputState;\n    if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        for (var i = 0; i < repeat; i++) {\n            repeatCommand();\n            repeatInsert(1);\n        }\n    }\n    else {\n        if (!repeatForInsert) {\n            repeatCommand();\n        }\n        repeatInsert(repeat);\n    }\n    vim.inputState = cachedInputState;\n    if (vim.insertMode && !repeatForInsert) {\n        exitInsertMode(cm);\n    }\n    macroModeState.isPlaying = false;\n}\nfunction sendCmKey(cm, key) {\n    CodeMirror.lookupKey(key, 'vim-insert', function keyHandler(binding) {\n        if (typeof binding == 'string') {\n            CodeMirror.commands[binding](cm);\n        }\n        else {\n            binding(cm);\n        }\n        return true;\n    });\n}\nfunction repeatInsertModeChanges(cm, changes, repeat) {\n    var head = cm.getCursor('head');\n    var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n    if (visualBlock) {\n        selectForInsert(cm, head, visualBlock + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n    }\n    for (var i = 0; i < repeat; i++) {\n        if (visualBlock) {\n            cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n            var change = changes[j];\n            if (change instanceof InsertModeKey) {\n                sendCmKey(cm, change.keyName, change);\n            }\n            else if (typeof change == \"string\") {\n                cm.replaceSelection(change);\n            }\n            else {\n                var start = cm.getCursor();\n                var end = offsetCursor(start, 0, change[0].length - (change[1] || 0));\n                cm.replaceRange(change[0], start, change[1] ? start : end);\n                cm.setCursor(end);\n            }\n        }\n    }\n    if (visualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n    }\n}\nCodeMirror.Vim = vimApi;\nvar specialKeyAce = { 'return': 'CR', backspace: 'BS', 'delete': 'Del', esc: 'Esc',\n    left: 'Left', right: 'Right', up: 'Up', down: 'Down', space: 'Space', insert: 'Ins',\n    home: 'Home', end: 'End', pageup: 'PageUp', pagedown: 'PageDown', enter: 'CR'\n};\nfunction lookupKey(hashId, key, e, vim) {\n    if (key.length > 1 && key[0] == \"n\") {\n        key = key.replace(\"numpad\", \"\");\n    }\n    key = specialKeyAce[key] || key;\n    var name = '';\n    if (e.ctrlKey) {\n        name += 'C-';\n    }\n    if (e.altKey) {\n        name += 'A-';\n    }\n    if ((name || key.length > 1) && e.shiftKey) {\n        name += 'S-';\n    }\n    if (vim && !vim.expectLiteralNext && key.length == 1) {\n        if (langmap.keymap && key in langmap.keymap) {\n            if (langmap.remapCtrl !== false || !name)\n                key = langmap.keymap[key];\n        }\n        else if (key.charCodeAt(0) > 255) {\n            var code = e.code && e.code.slice(-1) || \"\";\n            if (!e.shiftKey)\n                code = code.toLowerCase();\n            if (code)\n                key = code;\n        }\n    }\n    name += key;\n    if (name.length > 1) {\n        name = '<' + name + '>';\n    }\n    return name;\n}\nvar handleKey = vimApi.handleKey.bind(vimApi);\nvimApi.handleKey = function (cm, key, origin) {\n    return cm.operation(function () {\n        return handleKey(cm, key, origin);\n    }, true);\n};\nfunction cloneVimState(state) {\n    var n = new state.constructor();\n    Object.keys(state).forEach(function (key) {\n        if (key == \"insertEnd\")\n            return;\n        var o = state[key];\n        if (Array.isArray(o))\n            o = o.slice();\n        else if (o && typeof o == \"object\" && o.constructor != Object)\n            o = cloneVimState(o);\n        n[key] = o;\n    });\n    if (state.sel) {\n        n.sel = {\n            head: state.sel.head && copyCursor(state.sel.head),\n            anchor: state.sel.anchor && copyCursor(state.sel.anchor)\n        };\n    }\n    return n;\n}\nfunction multiSelectHandleKey(cm, key, origin) {\n    var isHandled = false;\n    var vim = vimApi.maybeInitVimState_(cm);\n    var visualBlock = vim.visualBlock || vim.wasInVisualBlock;\n    var wasMultiselect = cm.ace.inMultiSelectMode;\n    if (vim.wasInVisualBlock && !wasMultiselect) {\n        vim.wasInVisualBlock = false;\n    }\n    else if (wasMultiselect && vim.visualBlock) {\n        vim.wasInVisualBlock = true;\n    }\n    if (key == '<Esc>' && !vim.insertMode && !vim.visualMode && wasMultiselect) {\n        cm.ace.exitMultiSelectMode();\n    }\n    else if (visualBlock || !wasMultiselect || cm.ace.inVirtualSelectionMode) {\n        isHandled = vimApi.handleKey(cm, key, origin);\n    }\n    else {\n        var old = cloneVimState(vim);\n        var changeQueueList = vim.inputState.changeQueueList || [];\n        cm.operation(function () {\n            cm.curOp.isVimOp = true;\n            var index = 0;\n            cm.ace.forEachSelection(function () {\n                var sel = cm.ace.selection;\n                cm.state.vim.lastHPos = sel.$desiredColumn == null ? sel.lead.column : sel.$desiredColumn;\n                cm.state.vim.inputState.changeQueue = changeQueueList[index];\n                var head = cm.getCursor(\"head\");\n                var anchor = cm.getCursor(\"anchor\");\n                var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n                var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n                head = offsetCursor(head, 0, headOffset);\n                anchor = offsetCursor(anchor, 0, anchorOffset);\n                cm.state.vim.sel.head = head;\n                cm.state.vim.sel.anchor = anchor;\n                isHandled = handleKey(cm, key, origin);\n                sel.$desiredColumn = cm.state.vim.lastHPos == -1 ? null : cm.state.vim.lastHPos;\n                if (cm.ace.inVirtualSelectionMode) {\n                    changeQueueList[index] = cm.state.vim.inputState.changeQueue;\n                }\n                if (cm.virtualSelectionMode()) {\n                    cm.state.vim = cloneVimState(old);\n                }\n                index++;\n            });\n            if (cm.curOp.cursorActivity && !isHandled)\n                cm.curOp.cursorActivity = false;\n            vim.status = cm.state.vim.status;\n            cm.state.vim = vim;\n            vim.inputState.changeQueueList = changeQueueList;\n            vim.inputState.changeQueue = null;\n        }, true);\n    }\n    if (isHandled && !vim.visualMode && !vim.insert && vim.visualMode != cm.somethingSelected()) {\n        handleExternalSelection(cm, vim, true);\n    }\n    return isHandled;\n}\nresetVimGlobalState();\nexports.CodeMirror = CodeMirror;\nvar getVim = vimApi.maybeInitVimState_;\nexports.handler = {\n    $id: \"ace/keyboard/vim\",\n    drawCursor: function (element, pixelPos, config, sel, session) {\n        var vim = this.state.vim || {};\n        var w = config.characterWidth;\n        var h = config.lineHeight;\n        var top = pixelPos.top;\n        var left = pixelPos.left;\n        if (!vim.insertMode) {\n            var isbackwards = !sel.cursor\n                ? session.selection.isBackwards() || session.selection.isEmpty()\n                : Range.comparePoints(sel.cursor, sel.start) <= 0;\n            if (!isbackwards && left > w)\n                left -= w;\n        }\n        if (!vim.insertMode && vim.status) {\n            h = h / 2;\n            top += h;\n        }\n        domLib.translate(element, left, top);\n        domLib.setStyle(element.style, \"width\", w + \"px\");\n        domLib.setStyle(element.style, \"height\", h + \"px\");\n    },\n    $getDirectionForHighlight: function (editor) {\n        var cm = editor.state.cm;\n        var vim = getVim(cm);\n        if (!vim.insertMode) {\n            return editor.session.selection.isBackwards() || editor.session.selection.isEmpty();\n        }\n    },\n    handleKeyboard: function (data, hashId, key, keyCode, e) {\n        var editor = data.editor;\n        var cm = editor.state.cm;\n        var vim = getVim(cm);\n        if (keyCode == -1)\n            return;\n        if (!vim.insertMode) {\n            if (hashId == -1) {\n                if (key.charCodeAt(0) > 0xFF) {\n                    if (data.inputKey) {\n                        key = data.inputKey;\n                        if (key && data.inputHash == 4)\n                            key = key.toUpperCase();\n                    }\n                }\n                data.inputChar = key;\n            }\n            else if (hashId == 4 || hashId == 0) {\n                if (data.inputKey == key && data.inputHash == hashId && data.inputChar) {\n                    key = data.inputChar;\n                    hashId = -1;\n                }\n                else {\n                    data.inputChar = null;\n                    data.inputKey = key;\n                    data.inputHash = hashId;\n                }\n            }\n            else {\n                data.inputChar = data.inputKey = null;\n            }\n        }\n        if (cm.state.overwrite && vim.insertMode && key == \"backspace\" && hashId == 0) {\n            return { command: \"gotoleft\" };\n        }\n        if (key == \"c\" && hashId == 1) { // key == \"ctrl-c\"\n            if (!useragent.isMac && editor.getCopyText()) {\n                editor.once(\"copy\", function () {\n                    if (vim.insertMode)\n                        editor.selection.clearSelection();\n                    else\n                        cm.operation(function () { exitVisualMode(cm); });\n                });\n                return { command: \"null\", passEvent: true };\n            }\n        }\n        if (key == \"esc\" && !vim.insertMode && !vim.visualMode && !cm.ace.inMultiSelectMode) {\n            var searchState = getSearchState(cm);\n            var overlay = searchState.getOverlay();\n            if (overlay)\n                cm.removeOverlay(overlay);\n        }\n        if (hashId == -1 || hashId & 1 || hashId === 0 && key.length > 1) {\n            var insertMode = vim.insertMode;\n            var name = lookupKey(hashId, key, e || {}, vim);\n            if (vim.status == null)\n                vim.status = \"\";\n            var isHandled = multiSelectHandleKey(cm, name, 'user');\n            vim = getVim(cm); // may be changed by multiSelectHandleKey\n            if (isHandled && vim.status != null)\n                vim.status += name;\n            else if (vim.status == null)\n                vim.status = \"\";\n            cm._signal(\"changeStatus\");\n            if (!isHandled && (hashId != -1 || insertMode))\n                return;\n            return { command: \"null\", passEvent: !isHandled };\n        }\n    },\n    attach: function (editor) {\n        if (!editor.state)\n            editor.state = {};\n        var cm = new CodeMirror(editor);\n        editor.state.cm = cm;\n        editor.$vimModeHandler = this;\n        enterVimMode(cm);\n        getVim(cm).status = null;\n        cm.on('vim-command-done', function () {\n            if (cm.virtualSelectionMode())\n                return;\n            getVim(cm).status = null;\n            cm.ace._signal(\"changeStatus\");\n            cm.ace.session.markUndoGroup();\n        });\n        cm.on(\"changeStatus\", function () {\n            cm.ace.renderer.updateCursor();\n            cm.ace._signal(\"changeStatus\");\n        });\n        cm.on(\"vim-mode-change\", function () {\n            if (cm.virtualSelectionMode())\n                return;\n            updateInputMode();\n            cm._signal(\"changeStatus\");\n        });\n        function updateInputMode() {\n            var isIntsert = getVim(cm).insertMode;\n            cm.ace.renderer.setStyle(\"normal-mode\", !isIntsert);\n            editor.textInput.setCommandMode(!isIntsert);\n            editor.renderer.$keepTextAreaAtCursor = isIntsert;\n            editor.renderer.$blockCursor = !isIntsert;\n        }\n        updateInputMode();\n        editor.renderer.$cursorLayer.drawCursor = this.drawCursor.bind(cm);\n    },\n    detach: function (editor) {\n        var cm = editor.state.cm;\n        leaveVimMode(cm);\n        cm.destroy();\n        editor.state.cm = null;\n        editor.$vimModeHandler = null;\n        editor.renderer.$cursorLayer.drawCursor = null;\n        editor.renderer.setStyle(\"normal-mode\", false);\n        editor.textInput.setCommandMode(false);\n        editor.renderer.$keepTextAreaAtCursor = true;\n    },\n    getStatusText: function (editor) {\n        var cm = editor.state.cm;\n        var vim = getVim(cm);\n        if (vim.insertMode)\n            return \"INSERT\";\n        var status = \"\";\n        if (vim.visualMode) {\n            status += \"VISUAL\";\n            if (vim.visualLine)\n                status += \" LINE\";\n            if (vim.visualBlock)\n                status += \" BLOCK\";\n        }\n        if (vim.status)\n            status += (status ? \" \" : \"\") + vim.status;\n        return status;\n    }\n};\nvimApi.defineOption({\n    name: \"wrap\",\n    set: function (value, cm) {\n        if (cm) {\n            cm.ace.setOption(\"wrap\", value);\n        }\n    },\n    type: \"boolean\"\n}, false);\nvimApi.defineEx('write', 'w', function () {\n    console.log(':write is not implemented');\n});\ndefaultKeymap.push({ keys: 'zc', type: 'action', action: 'fold', actionArgs: { open: false } }, { keys: 'zC', type: 'action', action: 'fold', actionArgs: { open: false, all: true } }, { keys: 'zo', type: 'action', action: 'fold', actionArgs: { open: true } }, { keys: 'zO', type: 'action', action: 'fold', actionArgs: { open: true, all: true } }, { keys: 'za', type: 'action', action: 'fold', actionArgs: { toggle: true } }, { keys: 'zA', type: 'action', action: 'fold', actionArgs: { toggle: true, all: true } }, { keys: 'zf', type: 'action', action: 'fold', actionArgs: { open: true, all: true } }, { keys: 'zd', type: 'action', action: 'fold', actionArgs: { open: true, all: true } }, { keys: '<C-A-k>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorAbove\" } }, { keys: '<C-A-j>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorBelow\" } }, { keys: '<C-A-S-k>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorAboveSkipCurrent\" } }, { keys: '<C-A-S-j>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorBelowSkipCurrent\" } }, { keys: '<C-A-h>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectMoreBefore\" } }, { keys: '<C-A-l>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectMoreAfter\" } }, { keys: '<C-A-S-h>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectNextBefore\" } }, { keys: '<C-A-S-l>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectNextAfter\" } });\ndefaultKeymap.push({\n    keys: 'gq',\n    type: 'operator',\n    operator: 'hardWrap'\n});\nvimApi.defineOperator(\"hardWrap\", function (cm, operatorArgs, ranges, oldAnchor, newHead) {\n    var anchor = ranges[0].anchor.line;\n    var head = ranges[0].head.line;\n    if (operatorArgs.linewise)\n        head--;\n    hardWrap(cm.ace, { startRow: anchor, endRow: head });\n    return Pos(head, 0);\n});\ndefineOption('textwidth', undefined, 'number', ['tw'], function (width, cm) {\n    if (cm === undefined) {\n        return;\n    }\n    if (width === undefined) {\n        var value = cm.ace.getOption('printMarginColumn');\n        return value;\n    }\n    else {\n        var column = Math.round(width);\n        if (column > 1) {\n            cm.ace.setOption('printMarginColumn', column);\n        }\n    }\n});\nactions.aceCommand = function (cm, actionArgs, vim) {\n    cm.vimCmd = actionArgs;\n    if (cm.ace.inVirtualSelectionMode)\n        cm.ace.on(\"beforeEndOperation\", delayedExecAceCommand);\n    else\n        delayedExecAceCommand(null, cm.ace);\n};\nfunction delayedExecAceCommand(op, ace) {\n    ace.off(\"beforeEndOperation\", delayedExecAceCommand);\n    var cmd = ace.state.cm.vimCmd;\n    if (cmd) {\n        ace.execCommand(cmd.exec ? cmd : cmd.name, cmd.args);\n    }\n    ace.curOp = ace.prevOp;\n}\nactions.fold = function (cm, actionArgs, vim) {\n    cm.ace.execCommand(['toggleFoldWidget', 'toggleFoldWidget', 'foldOther', 'unfoldall'\n    ][(actionArgs.all ? 2 : 0) + (actionArgs.open ? 1 : 0)]);\n};\ndefaultKeymapLength = defaultKeymap.length; // ace_patch\nexports.handler.defaultKeymap = defaultKeymap;\nexports.handler.actions = actions;\nexports.Vim = vimApi;\n\n});                (function() {\n                    ace.require([\"ace/keyboard/vim\"], function(m) {\n                        if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n                            module.exports = m;\n                        }\n                    });\n                })();\n            "],
  "mappings": "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",
  "names": ["require", "exports", "module", "line", "max", "p", "ace", "lookupKey", "options", "o", "event", "prompt", "value", "query", "macroModeState", "e", "i", "dir", "cm", "searchState", "commandMatch", "noremap", "numberRegex", "repeat"]
}
